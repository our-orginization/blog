<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Chrome在电脑上模拟微信浏览器]]></title>
    <url>%2F2018%2F01%2F16%2Fchromweixin%2F</url>
    <content type="text"><![CDATA[最近做了微信商城的开发，涉及到在微信内部的页面跳转问题，用此方法调试。 1、先了解安卓微信和Ios微信的UA（User agent：用户代理） 安卓微信UA： mozilla/5.0 (linux; u; android 4.1.2; zh-cn; mi-one plus build/jzo54k) applewebkit/534.30 (khtml, like gecko) version/4.0 mobile safari/534.30 micromessenger/5.0.1.352 2、打开Chrome，F12打开开发人员工具，点击菜单按钮—–More Tools —–Network condition打开Network condition窗口 3、 User agent选项，选择Custom（自定义），然后在下面的文本框中输入Android或者Ios的UA就可以了 4、测试一下成果如何1234567891011121314151617&lt;script type=&quot;text/javascript&quot;&gt;window.onload = function() &#123; isWeixinBrowser();&#125;//判断是否微信浏览器function isWeixinBrowser() &#123; var ua = navigator.userAgent.toLowerCase(); var result = (/micromessenger/.test(ua)) ? true : false; if (result) &#123; console.log(&apos;你正在访问微信浏览器&apos;); &#125; else &#123; console.log(&apos;你访问的不是微信浏览器&apos;); &#125; return result;&#125; &lt;/script&gt;]]></content>
      <categories>
        <category>chrome</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript常见问题汇总（一）]]></title>
    <url>%2F2018%2F01%2F16%2Fjavascript%2F</url>
    <content type="text"><![CDATA[本文用于记录平时浏览资料或者工作过程中遇到的js关键知识点。 类型和类型转换在JavaScript中有7个内置类型：null，undefined，boolean，number，string，object，和symbol(ES6)。除了object外，其他的都叫做基本类型，可以通过typeof查看对应数据的类型。123456typeof 0 // &quot;number&quot;typeof true // &quot;boolean&quot;typeof &apos;hi&apos; // &quot;string&quot;typeof Math // &quot;object&quot;typeof null // &quot;object&quot;typeof Symbol(&apos;Hi&apos;) // &quot;symbol&quot; Null vs. undefined大多数计算机语言，有且仅有一个表示”无”的值，比如，C语言的NULL，Java语言的null，Python语言的None，Ruby语言的nil。有点奇怪的是，JavaScript语言居然有两个表示”无”的值：undefined和null。相似性在JavaScript中，将一个变量赋值为undefined或null，老实说，几乎没区别。12var a = undefined;var a = null; 上面代码中，a变量分别被赋值为undefined和null，这两种写法几乎等价。undefined和null在if语句中，都会被自动转为false，相等运算符甚至直接报告两者相等。差别null表示”没有对象”，即该处不应该有值。 作为函数的参数，表示该函数的参数不是对象。 作为对象原型链的终点。undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。 变量被声明了，但没有赋值时，就等于undefined。 调用函数时，应该提供的参数没有提供，该参数等于undefined。 对象没有赋值的属性，该属性的值为undefined。 函数没有返回值时，默认返回undefined。 隐式转换在if语句的条件判断中，””，0， null，undefined, NaN, false 会自动转换为false。其它的如空数组、对象、函数定义都会自动转换为真。123456Boolean(null) // falseBoolean(&apos;hello&apos;) // true Boolean(&apos;0&apos;) // true Boolean(&apos; &apos;) // true Boolean([]) // true Boolean(function()&#123;&#125;) // true String &amp; Number之间的转换首先你要非常小心的是 + 操作符。因为它同时用于数字相加和字符串拼接。*,/,-只用于数字运算，当这些操作符和字符串一起使用，那么字符串会被强制转换为数字。12345678910111 + &quot;2&quot; = &quot;12&quot;&quot;&quot; + 1 + 0 = &quot;10&quot;&quot;&quot; - 1 + 0 = -1&quot;-9\n&quot; + 5 = &quot;-9\n5&quot;&quot;-9\n&quot; - 5 = -14&quot;2&quot; * &quot;3&quot; = 64 + 5 + &quot;px&quot; = &quot;9px&quot;&quot;$&quot; + 4 + 5 = &quot;$45&quot;&quot;4&quot; - 2 = 2&quot;4px&quot; - 2 = NaNnull + 1 = 1 == vs. ===一个广泛被接受的认知就是：==判断值是否相等，===同时判断值是否相等和类型是否相同。但是，这里有些误解。实际上，==在验证相等性的时候，会对类型不同的值做一个类型转换。===对要判断的值不做类型转换。12345678910111213142 == &apos;2&apos; // True2 === &apos;2&apos; // Falseundefined == null // Trueundefined === null // False&apos;0&apos; == false // truefalse == &quot;&quot; // truefalse == [] // truefalse == &#123;&#125; // false&quot;&quot; == 0 // true&quot;&quot; == [] // true&quot;&quot; == &#123;&#125; // false0 == [] // true0 == &#123;&#125; // false0 == null // false 值 vs. 引用对于基本类型的值，赋值是通过值拷贝的形式；比如：null，undefined，boolean，number，string和ES6的symbol。对于复杂类型的值，通过引用拷贝的形式赋值。比如：对象、对象包括数组和函数。如果想对复杂类型的值进行拷贝，需要自己去对子元素进行拷贝。12345678910111213141516171819var a = 2; // 'a' hold a copy of the value 2.var b = a; // 'b' is always a copy of the value in 'a'b++;console.log(a); // 2console.log(b); // 3var c = [1,2,3];var d = c; // 'd' is a reference to the shared valued.push( 4 ); // Mutates the referenced value (object)console.log(c); // [1,2,3,4]console.log(d); // [1,2,3,4]/* Compound values are equal by reference */var e = [1,2,3,4];console.log(c === d); // trueconsole.log(c === e); // falseconst copy = c.slice() // 'copy' 即使copy和c相同，但是copy指向新的值console.log(c); // [1,2,3,4]console.log(copy); // [1,2,3,4]console.log(c === copy); // false 作用域(Scope)作用域值程序的执行环境，它包含了在当前位置可访问的变量和函数。全局作用域是最外层的作用域，在函数外面定义的变量属于全局作用域，可以被任何其他子作用域访问。在浏览器中，window对象就是全局作用域。局部作用域是在函数内部的作用域。在局部作用域定义的变量只能在该作用域以及其子作用域被访问。 提升在编译过程中，将var和function的定义移动到他们作用域最前面的行为叫做提升。整个函数定义会被提升12345console.log(toSquare(3)); // 9function toSquare(n)&#123; return n*n;&#125; 变量只会被部分提升(let和const不会被提升)。而且只有变量的声明会被提升，赋值不会动1234567891011121314151617181920212223&#123; /* Original code */ console.log(i); // undefined var i = 10 console.log(i); // 10&#125;&#123; /* Compilation phase */ var i; console.log(i); // undefined i = 10 console.log(i); // 10&#125;// ES6 let &amp; const&#123; console.log(i); // ReferenceError: i is not defined const i = 10 console.log(i); // 10&#125;&#123; console.log(i); // ReferenceError: i is not defined let i = 10 console.log(i); // 10&#125; 函数表达式和函数声明 函数表达式一个函数表达式是在函数执行到函数表达式定义的位置才开始创建，并被使用。它不会被提升。 123var sum = function(a, b) &#123; return a + b;&#125; 函数声明函数声明的函数可以在文件中任意位置调用，因为它会被提升。 123function sum(a, b) &#123; return a + b;&#125; 立即执行函数立即执行函数，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作,包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。显而易见，它不会被提升。立即执行函数可以用来实现模块化。 1234(function() &#123; // 代码 // ...&#125;)(); 变量let,var,const 在ES6之前，只能使用var来声明变量。在一个函数体中声明的变量和函数，周围的作用域内无法访问。在块作用域if和for中声明的变量，可以在if和for的外部被访问。如果没有使用var,let或则const关键字声明的变量将会绑定到全局作用域上。 ES6的let和const都是新引入的关键字。它们不会被提升，而且是块作用域。也就是说被大括号包围起来的区域声明的变量外部将不可访问。 使用const声明的变量，其值不可更改。准确地说它不可以被重新赋值，但是可以更改。1234567891011const tryMe = 'initial assignment';tryMe = 'this has been reassigned'; // TypeError: Assignment to constant variable.// You cannot reassign but you can change it…const array = ['Ted', 'is', 'awesome!'];array[0] = 'Barney';array[3] = 'Suit up!';console.log(array); // [“Barney”, “is”, “awesome!”, “Suit up!”]const airplane = &#123;&#125;;airplane.wings = 2;airplane.passengers = 200;console.log(airplane); // &#123;passengers: 200, wings: 2&#125; 闭包在前端面试中，闭包基本上是一个必问基础知识，然而一直以来我对闭包的理解都处于表面。那么什么是闭包呢？对于闭包(closure)，当外部函数返回之后，内部函数依然可以访问外部函数的变量。1234567891011121314151617function f1() &#123; var N = 0; // N是f1中的局部变量 // 内部函数f2中使用了外部函数f1中的变量N function f2() &#123; N += 1; console.log(N); &#125; return f2;&#125;var result = f1();result(); // 输出1result(); // 输出2result(); // 输出3 代码中，外部函数f1只执行了一次，变量N设为0，并将内部函数f2赋值给了变量result。由于外部函数f1已经执行完毕，其内部变量N应该在内存中被清除，然而事实并不是这样：我们每次调用result的时候，发现变量N一直在内存中，并且在累加。为什么呢？这就是闭包的神奇之处了！ 使用闭包定义私有变量123456789101112131415161718function Product() &#123; var name; this.setName = function(value) &#123; name = value; &#125;; this.getName = function() &#123; return name; &#125;;&#125;var p = new Product();p.setName("hello");console.log(p.name); // 输出undefinedconsole.log(p.getName()); // 输出hello 对象p的的name属性为私有属性，使用p.name不能直接访问。 继承JavaScript仅支持通过prototype属性进行继承属性和方法。每个JavaScript构造函数都有一个prototype属性，用于设置所有实例对象需要共享的属性和方法。12345678910111213141516171819function Rectangle(x, y)&#123; this._length = x; this._breadth = y;&#125;Rectangle.prototype.getDimensions = function()&#123; return &#123; length: this._length, breadth: this._breadth &#125;;&#125;;var x = new Rectangle(3, 4);var y = new Rectangle(4, 3);console.log(x.getDimensions()); // &#123; length: 3, breadth: 4 &#125;console.log(y.getDimensions()); // &#123; length: 4, breadth: 3 &#125; 柯里化我们可以一次性传入多个参数调用它；也可以只传入一部分参数来调用它，让它返回一个函数去处理剩下的参数。12345678910111213var add = function(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;;console.log(add(1)(1)); // 输出2var add1 = add(1);console.log(add1(1)); // 输出2var add10 = add(10);console.log(add10(1)); // 输出11]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex实现五种常用布局]]></title>
    <url>%2F2018%2F01%2F09%2Fflex%2F</url>
    <content type="text"><![CDATA[原文链接 经典上-中-下布局当页面内容高度小于可视区域高度时，footer 吸附在底部；当页面内容高度大于可视区域高度时，footer 被撑开排在 content 下方。12345&lt;body&gt; &lt;header&gt;HEADER&lt;/header&gt; &lt;article&gt;CONTENT&lt;/article&gt; &lt;footer&gt;FOOTER&lt;/footer&gt;&lt;/body&gt; 12345678body &#123; min-height: 100vh; display: flex; flex-direction: column;&#125;article &#123; flex: auto;&#125; 在上-中-下布局的基础上，加了左侧定宽 sidebar12345678&lt;body&gt; &lt;header&gt;HEADER&lt;/header&gt; &lt;div class="content"&gt; &lt;aside&gt;ASIDE&lt;/aside&gt; &lt;article&gt;CONTENT&lt;/article&gt; &lt;/div&gt; &lt;footer&gt;FOOTER&lt;/footer&gt;&lt;/body&gt; 12345678910111213141516body &#123; min-height: 100vh; display: flex; flex-direction: column; &#125; .content &#123; flex: auto; display: flex; &#125; .content article &#123; flex: auto; &#125; .content aside &#123; flex: none; width: 200px; &#125; 左边是定宽 sidebar，右边是上-中-下布局。12345678&lt;body&gt; &lt;aside&gt;ASIDE&lt;/aside&gt; &lt;div class="content"&gt; &lt;header&gt;HEADER&lt;/header&gt; &lt;article&gt;CONTENT&lt;/article&gt; &lt;footer&gt;FOOTER&lt;/footer&gt; &lt;/div&gt;&lt;/body&gt; 12345678910111213141516body &#123; min-height: 100vh; display: flex; &#125; aside &#123; flex: none; width: 200px; &#125; .content &#123; flex: auto; display: flex; flex-direction: column; &#125; .content article &#123; flex: auto; &#125; 还是上-中-下布局，区别是 header 固定在顶部，不会随着页面滚动。12345&lt;body&gt; &lt;header&gt;HEADER&lt;/header&gt; &lt;article&gt;CONTENT&lt;/article&gt; &lt;footer&gt;FOOTER&lt;/footer&gt;&lt;/body&gt; 123456789101112131415161718body &#123; min-height: 100vh; display: flex; flex-direction: column; padding-top: 60px; &#125; header &#123; height: 60px; position: fixed; top: 0; left: 0; right: 0; padding: 0; &#125; article &#123; flex: auto; height: 1000px; &#125; 左侧 sidebar 固定在左侧且与视窗同高，当内容超出视窗高度时，在 sidebar 内部出现滚动条。左右两侧滚动条互相独立。1234567891011121314&lt;body&gt; &lt;aside&gt; ASIDE &lt;p&gt;item&lt;/p&gt; &lt;p&gt;item&lt;/p&gt; &lt;!-- many items --&gt; &lt;p&gt;item&lt;/p&gt; &lt;/aside&gt; &lt;div class="content"&gt; &lt;header&gt;HEADER&lt;/header&gt; &lt;article&gt;CONTENT&lt;/article&gt; &lt;footer&gt;FOOTER&lt;/footer&gt; &lt;/div&gt;&lt;/body&gt; 12345678910111213141516171819body &#123; height: 100vh; display: flex;&#125;aside &#123; flex: none; width: 200px; overflow-y: auto; display: block;&#125;.content &#123; flex: auto; display: flex; flex-direction: column; overflow-y: auto;&#125;.content article &#123; flex: auto;&#125;]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>flex</tag>
        <tag>布局</tag>
        <tag>Layout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端页面开发手记（一）]]></title>
    <url>%2F2017%2F12%2F25%2Fmobile%2F</url>
    <content type="text"><![CDATA[A pixel is not a pixel is not a pixel. 一.像素像素是web页面布局的基础，那么到底什么才是一个像素呢？在PC开发时，我对像素的理解就是简单的1个px。 那么看看百度百科的解释：像素是指由图像的小方格即所谓的像素(pixel)组成的，这些小方块都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置就决定该图像所呈现出来的样子。可以将像素视为整个图像中不可分割的单位或者是元素，不可分割的意思是它不能够再切割成更小单位抑或是元素，它是以一个单一颜色的小格存在。每一个点阵图像包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小。 实际上，在Web开发领域，像素有以下两层含义： 设备像素：设备屏幕的物理像素，对于任何设备来讲物理像素的数量是固定的。比如iPhone 5的分辨率640 x 1136px。。 CSS像素：这是一个抽象的像素概念，它是Web编程的概念，指的是CSS样式代码中使用的逻辑像素。在CSS规范中，长度单位可以分为两类，绝对(absolute)单位以及相对(relative)单位。px是一个相对单位，相对的是设备像素(device pixel)。 如下图，是在缩放比例为1，即scale = 1的情况下，设备像素和CSS像素示意图: 那么再深入的考虑这样一个问题，当我给一个元素设置了 width: 200px;这条样式的时候，到底发生了什么事情？ 可能有人会说：“废话！元素的宽度是200px呗。”对，并没有什么问题，但是这个200px指的是什么呢？因为我们知道，对于web前端来讲像素有两层含义，那么到底是设备像素还是CSS像素？实际上我们控制的是CSS像素，因为前面提到了，CSS像素是给我们web前端开发者创造的抽象概念。所以你要记住：当你给元素设置了 width: 200px 时，这个元素的宽度跨越了200个CSS像素。但是它并不一定跨越200个设备像素，至于会跨越多少个设备像素，就取决于手机屏幕的特性和用户的缩放了,举个栗子： 苹果手机的Retina视网膜屏幕，是一个高密度屏幕，它的像素密度是普通屏幕的2倍，所以当我们设置 width: 2px; 时，2个CSS像素跨越了4个设备像素如图： CSS像素的大小是可变的，比如用后缩放页面的时候，实际上就是在缩小或放大CSS像素，而设备像素无论大小还是数量都是不变的。 二.移动端的三个视图你一定写过这样一条样式： width:25%; 但是你有想过给一个元素加上这样一条样式之后发生了什么吗？25%是基于谁的25%？明白的同学可能知道了：一个块元素默认的宽度是其父元素的100%，是基于起父元素的，所以25%指的是父元素宽度的25%，所以，body元素的默认宽度是html元素宽度的100%，那么你有没有想过html元素的宽度是基于谁的呢？这个时候，就要引出一个概念：初始包含块和视口。 记住一句话：视口是html的父元素，所以我们称视口为初始包含块。 这样你就明白了，html元素的百分比是基于视口的。 视图一： 布局视口布局视口：移动端CSS布局的依据视口，即CSS布局会根据布局视口来计算。写过css的小伙伴应该知道，我们在 html、 body设置 width:100%;height:100%;的时候，它并不是无效的。我们都知道 100%这种百分数应该是继承父元素而来的。那在这里是继承哪里的呢？在PC浏览器中，有一个用来约束CSS布局视口的东西，又叫做初始包含块。这也就是所有宽高继承的由来。除去 margin、 padding，布局视口和浏览器可视窗口宽度是一致的，同时也和浏览器本身的宽度一致。在PC浏览器中，视口只有一个，并且 视口的宽度 = 浏览器窗口的宽度，但是在移动端也要根据这个来设计的话，那么PC端设计的网站在移动端看起来会很丑，因为PC端的网页宽度在800 ~ 1024个CSS像素，而手机屏幕要窄的多，这个时候再PC端25%的宽度在移动端看起来会很窄。所以，布局视口的概念产生了。 也就是说，在移动端，视口和浏览器窗口将不在关联，实际上，布局视口要比浏览器窗口大的多(在手机和平板中浏览器布局视口的宽度在768~1024像素之间)，如下图（布局视口和窗口的关系）： 可以通过以下JavaScript代码获取布局视口的宽度和高度：12document.documentElement.clientWidthdocument.documentElement.clientHeight 视图二： 视觉视图对于视觉视口来说，这个东西是呈现给用户的，它是用户看到网页区域内CSS像素的数量。由于用户可以自行进行缩放控制，所以这个视口并不是开发者需要重点关注的。值得注意的是，在移动端缩放不会改变布局视口的宽度，当缩小的时候，屏幕覆盖的css像素变多，视觉视口变大，反之亦然。而在PC端，缩放对应布局宽度和视觉窗口宽度都是联动的。而浏览器宽度本身是固定的，无论怎么缩放都不受影响。如果对上面的宽度还是很乱，那么这里有一个表格可以帮助你理清思路。以下表格横向都以浏览器窗口的宽度作为基准： PC端状态 | 布局视口 | 视觉视口 | 浏览器窗口（基准）—–|—–|—–|—–默认 | 相等 | 相等 | -放大 | 变小 | 变小 | -缩小 | 变大 | 变大 | - 移动端状态 | 布局视口 | 视觉视口 | 浏览器窗口（基准）—–|—–|—–|—–默认 | 偏大 | 相等 | -放大 | 不变 | 变小 | -缩小 | 不变 | 变大 | - 视图三： 理想视图我们前面提到过，布局视口的宽度一般在 680~1024像素之间，这样可以使得PC网站在手机中不被压扁，但是这并不理想，因为手机更适合窄的网站，换句话说，布局视口并不是最理想的宽度，所以，就引入了理想视口。 理想视口，定义了理想视口的宽度，比如对于iphone5来讲，理想视口是320*568。但是最终作用的还是布局视口，因为我们的css是依据布局视口计算的，所以你可以这样理解理想视口：理想的布局视口。下面这段代码可以告诉手机浏览器要把布局视口设为理想视口：1&lt;meta name="viewport" content="width=device-width" /&gt; 然而，这段代码其实也并不完美，在IE浏览器中，由于横屏竖屏的切换会对其造成影响，为了解决这个兼容性的问题，最后再加上一句，就有了现在的：1&lt;meta name="viewport" content="width=device-width" initial-scale=1.0/&gt; initial-scale=1 的意思是初始缩放的比例是1，使用它的时候，同时也会将布局视口的尺寸设置为缩放后的尺寸。而缩放的尺寸就是基于屏幕的宽度来的，也就起到了和width=device-width1234567891011121314151617181920212223242526272829303132333435总结一下：- 在PC端，布局视口就是浏览器窗口- 在移动端，视口被分为两个：布局视口、视觉视口。- 移动端还有一个理想视口，它是布局视口的理想尺寸，即理想的布局视口。- 可以将布局视口的宽度设为理想视口### 三、设备像素比(Device Pixel Ratio 简称：DPR)有时候我们会发现，当我们在适某一机型的时候，显示上没什么问题。但是一旦我换到另外一部手机，发现出现了模糊的情况，尤其以图片更为显著。其实这个问题，就是涉及到了上面讲到的一个属性：设备像素比，即我们经常说的dpr。下面先来看dpr的表现：假设现在有一台iphone6，那么它的设备独立像素是375x667，dpr为2，尺寸是4.7in，那么物理像素就是750x1334。同样的我们也有一台不知名的设备，它的设备独立像素刚好也是375x667，尺寸也是4.7in，但是dpr为1，此时的物理像素就是375x667。下面是设备像素比的计算公式（公式成立的大前提：缩放比例为1）：###### 设备像素比(DPR) = 设备像素个数 / 理想视口CSS像素个数(device-width)与理想视口一样，设备像素比对于不同的设备是不同的，但是他们都是合理的，比如早起iphone的设备像素是320px，理想视口也是320px，所以早起iphone的DPR=1，而后来iphone的设备像素为640px，理想视口还是320px，所以后来iphone的DPR=2。而对于缩放来说，**缩小放大的是 CSS像素**。#### 模糊的产生知道了1个css像素覆盖的物理像素可能不同，就好理解为什么会出现模糊的情况了。这里又讲到一个名词：**位图像素**。位图像素是栅格图像（如：png,jpg,gif等）最小的数据单元。每一个位图像素都包含着一些自身的显示信息。（如：显示位置，颜色值，透明度等）理论上来说，**1个位图像素对应1个物理像素，图片才能等到完美清晰的展示**。但是上面说过，在retina屏幕上，会出现1个位图像素对应多个物理像素。还是以iphone6为例，1个位图像素对应4个物理像素。由于单个位图像素已经是最小的数据单位了，它不能再被进行切割。于是为了能够显示出来，就只能就近取色，从而导致所谓的图片模糊问题。#### 如何解决很明显，由于位图像素不够分而产生模糊的情况，解决的办法十分简单，就是使用跟dpr同个倍数大小的图片。比如iphone6，一个200x300的 img标签，原图就要提供400x600的大小。那么当加载到 img标签中，浏览器会自动对每1px的css像素减半，可以理解为此时还是维持着1:1的css像素:物理像素，不产生模糊。这个做法其实就是手淘团队在做retina适配的一个重要的原理之一，后面会讲到，这里先放着不说。### 四.meta标签meta视口标签存在的主要目的是为了让布局视口和理想视口的宽度匹配，meta视口标签应该放在HTML文档的head标签内，语法如下：```html &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt; 其中 content 属性是一个字符串值，字符串是由逗号“，”分隔的 名/值 对组成，共有5个： width：设置布局视口的宽 init-scale：设置页面的初始缩放程度 minimum-scale：设置了页面最小缩放程度 maximum-scale：设置了页面最大缩放程度 user-scalable：是否允许用户对页面进行缩放操作 上面代码的意思是，让布局视口的宽度等于理想视口的宽度，页面的初始缩放比例以及最大缩放比例都为1，且不允许用户对页面进行缩放操作。]]></content>
      <categories>
        <category>web mobile</category>
      </categories>
      <tags>
        <tag>mobile</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular4]]></title>
    <url>%2F2017%2F11%2F02%2Fangular4%2F</url>
    <content type="text"><![CDATA[本文主要介绍了angular4的用法和新特性。 Angular 与 AngularJS 有什么区别 不再有Controller和 Scope 更好的组件化及代码npm复用 更好的移动端支持 引入了 RxJS 与 Observable 引入了 Zone.js，提供更加智能的变化检测 特点 跨平台 高性能 多种IDE支持 环境搭建基础要求 Node.js Git 环境配置 安装 Angular CLI 1npm install -g @angular/cli 检测 Angular CLI 是否安装成功 1ng --version 创建新的项目 1ng new PROJECT-NAME 这个CLI为我们创建了第一个Angular组件。 它就是名叫app-root的根组件。 你可以在./src/app/app.component.ts目录下找到它。 启动本地服务器12cd PROJECT-NAMEng serve 使用–open（或-o）参数可以自动打开浏览器并访问http://localhost:4200/。 基础知识显示数据插值表达式在 Angular 中，我们可以使用插值语法实现数据绑定。Angular 自动从组件中提取属性的值，并且把这些值插入浏览器中。当这些属性发生变化时，Angular 就会自动刷新显示。Angular 先对它求值，再把它转换成字符串。1234567891011121314151617181920import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'app-root', template: ` &lt;h2&gt;大家好，我是&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;p&gt;我来自&lt;strong&gt;&#123;&#123;address.province&#125;&#125;&lt;/strong&gt;省, &lt;strong&gt;&#123;&#123;address.city&#125;&#125;&lt;/strong&gt;市 &lt;/p&gt; &lt;p&gt;&#123;&#123;address|json&#125;&#125;&lt;/p&gt; `, styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; name = 'Semlinker'; address = &#123; province: '福建', city: '厦门' &#125;&#125; 值得一提的是，这里使用了 Angular 内置的 json 管道。@Component装饰器中指定的 CSS 选择器selector，它指定了一个叫app-root的元素。 该元素是index.html的body里的占位符。当通过main.ts中的AppComponent类启动时，Angular 在index.html中查找一个my-app元素， 然后实例化一个AppComponent，并将其渲染到my-app标签中。123&lt;body&gt; &lt;app-root&gt;&lt;/app-root&gt;&lt;/body&gt; 插值表达式可以把计算后的字符串插入到 HTML 元素标签内的文本或对标签的属性进行赋值。1234&lt;h3&gt; &#123;&#123;title&#125;&#125; &lt;img src="&#123;&#123;heroImageUrl&#125;&#125;" style="height:30px"&gt;&lt;/h3&gt; 根据json管道补充一下管道操作符（|）：在绑定之前，表达式的结果可能需要一些转换。例如，可能希望把数字显示成金额、强制文本变成大写，或者过滤列表以及进行排序。 模板语法模板表达式模板表达式产生一个值。 Angular 执行这个表达式，并把它赋值给绑定目标的属性，这个绑定目标可能是 HTML 元素、组件或指令。JavaScript 中那些具有或可能引发副作用的表达式是被禁止的，包括： 赋值 (=, +=, -=, …) new运算符 使用;或,的链式表达式 自增或自减操作符 (++和–) 表达式中的上下文变量是由模板变量、指令的上下文变量（如果有）和组件的成员叠加而成的。 如果我们要引用的变量名存在于一个以上的命名空间中，那么，模板变量是最优先的，其次是指令的上下文变量，最后是组件的成员。 模板语句模板语句用来响应由绑定目标（如 HTML 元素、组件或指令）触发的事件。它出现在=号右侧的引号中，就像这样：(event)=”statement”。某些 JavaScript 语法是不允许的： new运算符 自增和自减运算符：++和– 操作并赋值，例如+=和-= 位操作符|和&amp; 模板表达式运算符 语句上下文可以引用模板自身上下文中的属性。 在下面的例子中，就把模板的$event对象、模板输入变量 (let hero)和模板引用变量 (#heroForm)传给了组件中的一个事件处理器方法。123&lt;button (click)="onSave($event)"&gt;Save&lt;/button&gt;&lt;button *ngFor="let hero of heroes" (click)="deleteHero(hero)"&gt;&#123;&#123;hero.name&#125;&#125;&lt;/button&gt;&lt;form #heroForm (ngSubmit)="onSubmit(heroForm)"&gt; ... &lt;/form&gt; 数据绑定和数据方向 1.单向（数据源-&gt;视图）： 插值表达式 Property Attribute 类 样式123&#123;&#123;expression&#125;&#125;[target]=&quot;expression&quot;bind-target=&quot;expression&quot; 注1.方括号表示要计算的模板表达式，不加方括号，Angular会将表达式视为字符串，而不会计算这个字符串。注2.当要渲染的数据类型是字符串时，倾向于使用插值表达式，否则必须使用属性绑定。注3.当元素没有属性可绑的时候，就必须使用 attribute 绑定。123456789&lt;table border=1&gt; &lt;!-- expression calculates colspan=2 --&gt; &lt;tr&gt;&lt;td [attr.colspan]="1 + 1"&gt;One-Two&lt;/td&gt;&lt;/tr&gt; &lt;!-- ERROR: There is no `colspan` property to set! &lt;tr&gt;&lt;td colspan="&#123;&#123;1 + 1&#125;&#125;"&gt;Three-Four&lt;/td&gt;&lt;/tr&gt; --&gt; &lt;tr&gt;&lt;td&gt;Five&lt;/td&gt;&lt;td&gt;Six&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 注4.css类绑定123456789&lt;!-- 当badCurly有值的时候，整个class设置的内容全部被覆盖 --&gt;&lt;div class="bad curly special" [class]="badCurly"&gt;Bad curly&lt;/div&gt;&lt;!-- 模板表达式的值为真时，添加这个类，否则移除 --&gt;&lt;div [class.special]="isSpecial"&gt;The class binding is special&lt;/div&gt;&lt;div class="special" [class.special]="!isSpecial"&gt;This one is not so special&lt;/div&gt; 注5.style样式绑定样式绑定的语法与属性绑定类似。 但方括号中的部分不是元素的属性名，而由style前缀，一个点和 CSS 样式的属性名组成。 形如：[style.style-property]。12&lt;button [style.font-size.em]="isSpecial ? 3 : 1" &gt;Big&lt;/button&gt;&lt;button [style.font-size.%]="!isSpecial ? 150 : 50" &gt;Small&lt;/button&gt; 2.单向（视图-&gt;数据源）： 事件12(targrt)=&quot;statement&quot;on-target=&quot;statement&quot; 事件对象的形态取决于目标事件。如果目标事件是原生 DOM 元素事件， $event就是 DOM事件对象，它有像target和target.value这样的属性。12&lt;input [value]="currentHero.name" (input)="currentHero.name=$event.target.value" &gt; 3.双向12[(target)]=&quot;expression&quot;bindon-target=&quot;expression&quot; 在 Angular 的世界中，attribute 唯一的作用是用来初始化元素和指令的状态。 当进行数据绑定时，只是在与元素和指令的 property 和事件打交道，而 attribute 就完全靠边站了。1234567891011121314151617181920212223import &#123; Component, EventEmitter, Input, Output &#125; from '@angular/core'; @Component(&#123; selector: 'app-sizer', template: ` &lt;div&gt; &lt;button (click)="dec()" title="smaller"&gt;-&lt;/button&gt; &lt;button (click)="inc()" title="bigger"&gt;+&lt;/button&gt; &lt;label [style.font-size.px]="size"&gt;FontSize: &#123;&#123;size&#125;&#125;px&lt;/label&gt; &lt;/div&gt;`&#125;)export class SizerComponent &#123; @Input() size: number | string; @Output() sizeChange = new EventEmitter&lt;number&gt;(); dec() &#123; this.resize(-1); &#125; inc() &#123; this.resize(+1); &#125; resize(delta: number) &#123; this.size = Math.min(40, Math.max(8, +this.size + delta)); this.sizeChange.emit(this.size); &#125;&#125; 12&lt;app-sizer [(size)]="fontSizePx"&gt;&lt;/app-sizer&gt;&lt;div [style.font-size.px]="fontSizePx"&gt;Resizable Text&lt;/div&gt; 内置指令 内置属性型指令 NgClass - 添加或移除一组CSS类可以把ngClass绑定到一个 key:value 形式的控制对象。这个对象中的每个 key 都是一个 CSS 类名，如果它的 value 是true，这个类就会被加上，否则就会被移除。123456789currentClasses: &#123;&#125;;setCurrentClasses() &#123; // CSS classes: added/removed per current state of component properties this.currentClasses = &#123; 'saveable': this.canSave, 'modified': !this.isUnchanged, 'special': this.isSpecial &#125;;&#125; 1&lt;div [ngClass]="currentClasses"&gt;test&lt;/div&gt; NgStyle - 添加或移除一组CSS样式NgStyle需要绑定到一个 key:value控制对象。 对象的每个 key 是样式名，它的 value 是能用于这个样式的任何值。123456789currentStyles: &#123;&#125;;setCurrentStyles() &#123; // CSS styles: set per current state of component properties this.currentStyles = &#123; 'font-style': this.canSave ? 'italic' : 'normal', 'font-weight': !this.isUnchanged ? 'bold' : 'normal', 'font-size': this.isSpecial ? '24px' : '12px' &#125;;&#125; 1&lt;div [ngStyle]="currentStyles"&gt;test&lt;/div&gt; NgModel - 双向绑定到HTML表单元素在使用ngModel指令进行双向数据绑定之前，我们必须导入FormsModule并把它添加到Angular模块的imports列表中。 2.内置结构型指令 NgIf - 根据条件把一个元素添加到DOM中或从DOM移除 1&lt;app-hero-detail *ngIf="isActive"&gt;&lt;/app-hero-detail&gt; NgSwitch - 一组指令，用于切换一组视图 123456&lt;div [ngSwitch]="currentHero.emotion"&gt; &lt;app-happy-hero *ngSwitchCase="'happy'" [hero]="currentHero"&gt;&lt;/app-happy-hero&gt; &lt;app-sad-hero *ngSwitchCase="'sad'" [hero]="currentHero"&gt;&lt;/app-sad-hero&gt; &lt;app-confused-hero *ngSwitchCase="'confused'" [hero]="currentHero"&gt;&lt;/app-confused-hero&gt; &lt;app-unknown-hero *ngSwitchDefault [hero]="currentHero"&gt;&lt;/app-unknown-hero&gt;&lt;/div&gt; NgForOf - 对列表中的每个条目重复套用同一个模板 12&lt;div *ngFor="let hero of heroes"&gt;&#123;&#123;hero.name&#125;&#125;&lt;/div&gt;&lt;div *ngFor="let hero of heroes; let i=index"&gt;&#123;&#123;i + 1&#125;&#125; - &#123;&#123;hero.name&#125;&#125;&lt;/div&gt; 模板引用变量（#）模板引用变量通常用来引用模板中的某个DOM元素。12&lt;input #phone placeholder="phone number"&gt;&lt;button (click)="callPhone(phone.value)"&gt;Call&lt;/button&gt; 输入输出属性12&lt;app-hero-detail [hero]="currentHero" (deleteRequest)="deleteHero($event)"&gt;&lt;/app-hero-detail&gt; 在HeroDetailComponent内部，这些属性被装饰器标记成了输入和输出属性。12@Input() hero: Hero;@Output() deleteRequest = new EventEmitter&lt;Hero&gt;(); 从HeroDetailComponent角度来看，HeroDetailComponent.hero是个输入属性， 因为数据流从模板绑定表达式流入那个属性。从HeroDetailComponent角度来看，HeroDetailComponent.deleteRequest是个输出属性， 因为事件从那个属性流出，流向模板绑定语句中的处理器。 为输出属性起别名：1@Output('myClick') clicks = new EventEmitter&lt;string&gt;(); 模板表达式操作符 管道操作符（|） 安全导航操作符 ( ?. ) 和空属性路径Angular 安全导航操作符 (?.) 是在属性路径中保护空值的更加流畅、便利的方式。 表达式会在它遇到第一个空值的时候跳出。 显示是空的，但应用正常工作，而没有发生错误。 12&lt;!-- No hero, no problem! --&gt;The null hero's name is &#123;&#123;nullHero?.name&#125;&#125; 非空断言操作符（!）在 Angular 编译器把你的模板转换成 TypeScript 代码时，这个操作符会防止 TypeScript 报告 “hero.name可能为null或undefined”的错误。 123&lt;div *ngIf="hero"&gt; The hero's name is &#123;&#123;hero!.name&#125;&#125;&lt;/div&gt; 内联 (inline)模板和模板文件可以使用template属性把它定义为内联的，或者把模板定义在一个独立的 HTML 文件中， 再通过@Component装饰器中的templateUrl属性， 在组件元数据中把它链接到组件。12345@Component(&#123; selector: 'app-home', templateUrl: './home.component.html', styleUrls: ['./home.component.css']&#125;) 1234567891011@Component(&#123; selector: 'app-root', template: ` &lt;h2&gt;大家好，我是&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;p&gt;我来自&lt;strong&gt;&#123;&#123;address.province&#125;&#125;&lt;/strong&gt;省, &lt;strong&gt;&#123;&#123;address.city&#125;&#125;&lt;/strong&gt;市 &lt;/p&gt; &lt;p&gt;&#123;&#123;address|json&#125;&#125;&lt;/p&gt; `, styleUrls: ['./app.component.css']&#125;) 组件交互1.通过输入型绑定把数据从父组件传到子组件 @Input()，需要import入core中的Input类2.通过setter截听输入属性值的变化12345678910111213141516import &#123; Component, Input &#125; from '@angular/core'; @Component(&#123; selector: 'app-name-child', template: '&lt;h3&gt;"&#123;&#123;name&#125;&#125;"&lt;/h3&gt;'&#125;)export class NameChildComponent &#123; private _name = ''; @Input() set name(name: string) &#123; this._name = (name &amp;&amp; name.trim()) || '&lt;no name set&gt;'; &#125; get name(): string &#123; return this._name; &#125;&#125; 3.通过ngOnChanges()来截听输入属性值的变化使用OnChanges生命周期钩子接口的ngOnChanges()方法来监测输入属性值的变化并做出回应。 未完待续]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs]]></title>
    <url>%2F2017%2F09%2F25%2Fnodejs%2F</url>
    <content type="text"><![CDATA[本文主要是一个nodejs的学习笔记。 前言NodeJs 可以解析Js代码（没有浏览器安全级别的限制）提供系统级别的API： 文件的读写 进程管理 网络通信 Node.js的版本： 偶数位为稳定版本（0.6.x 0.8.x) 奇数为非稳定版本 (0.5.x 0.7.x) 在Mac环境下搭建一个简单的web服务器前提： 安装xcode xcode-select –install 检查是否已经安装 Python 安装 Homebrew 安装 Node 创建 Demo 目录 在以上步骤都准备好后，可以开始搭建我们最简单的Web服务器了，新建文件server.js，粘贴下面代码。123456var http = require('http');http.createServer(function(req,res)&#123; res.writeHead(200,&#123;'Content-Type':'text/plain'&#125;); res.end('Hello World\n');&#125;).listen(1337,'127.0.0.1');console.log('Server running at http://127.0.0.1:1337/'); 然后，在server.js目录下运行命令，即可启动Web服务器。1node serve.js 这样，就可以通过访问127.0.0.1:1337访问到我们的Hello World页面了。 模块与包管理工具js的天生缺陷——缺少模块化管理机制·表现 JS中容易出现变量被覆盖，方法被替代的情况（既被污染）。特别是存在依赖关系时，容易出现错误。这是因为JS缺少模块管理机制，来隔离实现各种不同功能的JS判断，避免它们相互污染。 ·解决 经常采用命名空间的方式，把变量和函数限制在某个特定的作用域内，人肉约定一套命名规范来限制代码，保证代码安全运行。jQuery中有许多变量和方法，但是无法直接访问，必须通过jQuery，$调用各个方法。 Commonjs规范不同于jQuery，Commonjs是一套规范，约定了js如何组织，如何编写，包括包，二进制，套接字，单元测试等等。大部分标准在拟定和讨论之中，首先把执行不同任务的代码块和代码文件看为独立的模块，每一个模块都是一个单独的作用域，但不是孤立的，可能存在依赖关系。每个模块分为三个部分，定义、标识和引用。这套规范与现实产品如node.js相互影响，良性循环。 NodeJs的模块管理机制基于commonjs实现了模块管理系统。node中每一个js文件都是一个独立的模块，在其内部不需要有命名空间，不需要担心变量的污染和方法定义时的隔离。同时模块之间可以组合形成更强大的模块或功能包。npm即是用来管理各种功能包的。 模块的分类 模块的分类: 核心模块、文件模块、第三方模块； 模块的引用：可以通过路径和模块名。模块名引用最终也会被映射为路径。包含了核心函数的核心模块会在node启动时被预先加载。 文件模块、第三方模块 都是非核心模块，文件模块就是本地模块。 创建一个最简单的nodejs模块1.创建student.js12345function add(student) &#123; console.log("Add student:" + student);&#125;exports.add = add; 2.创建tescher.js12345function add(teacher) &#123; console.log("Add teache:" + teacher);&#125;exports.add = add; 3.创建klass.js，引入上面两个模块1234567891011var student = require('./student');var teacher= require('./teacher');function add (teacherName, students) &#123; teacher.add(teacherName); students.forEach(function(item, index) &#123; student.add(item); &#125;);&#125;exports.add = add; 4.创建index.js，调用klass模块123var klass = require('./klass');klass.add('Lily', ['hoho', 'xixi']); 最终，在命令行中执行node index.js，输出结果如下：1234➜ school node index.jsAdd teache:LilyAdd student:hohoAdd student:xixi Node的APIURL网址解析url解析url.parse(urlString, 是否把query转为对象, 是否识别未知协议的url);12345678910&gt; url&#123; Url: [Function: Url], parse: [Function: urlParse], resolve: [Function: urlResolve], resolveObject: [Function: urlResolveObject], format: [Function: urlFormat], URL: [Function: URL], URLSearchParams: [Function: URLSearchParams], domainToASCII: [Function: domainToASCII], domainToUnicode: [Function: domainToUnicode] &#125; 1234567891011121314&gt; url.parse(&apos;http://www.imooc.com/video/6710?form=scott#loor1&apos;)Url &#123; protocol: &apos;http:&apos;, slashes: true, auth: null, host: &apos;www.imooc.com&apos;, port: null, hostname: &apos;www.imooc.com&apos;, hash: &apos;#loor1&apos;, search: &apos;?form=scott&apos;, query: &apos;form=scott&apos;, pathname: &apos;/video/6710&apos;, path: &apos;/video/6710?form=scott&apos;, href: &apos;http://www.imooc.com/video/6710?form=scott#loor1&apos; &#125; url格式化url.format({})1234567891011121314&gt; url.format(&#123;... protocol: &apos;http:&apos;,... slashes: true,... auth: null,... host: &apos;www.imooc.com&apos;,... port: null,... hostname: &apos;www.imooc.com&apos;,... hash: &apos;#loor1&apos;,... search: &apos;?form=scott&apos;,... query: &apos;form=scott&apos;,... pathname: &apos;/video/6710&apos;,... path: &apos;/video/6710?form=scott&apos;,... href: &apos;http://www.imooc.com/video/6710?form=scott#loor1&apos; &#125;)&apos;http://www.imooc.com/video/6710?form=scott#loor1&apos; url拼接url.resolve(str1, str2)12&gt; url.resolve(&apos;http://immoc.com/&apos;, &apos;/course/list&apos;)&apos;http://immoc.com/course/list&apos; querystring参数解析参数序列化querystring.stringify({}, 参数之间的连接符-默认为&amp;, key和value之间的符号-默认=)12345678&gt; querystring.stringify(&#123;name:&apos;scott&apos;, course:[&apos;jade&apos;,&apos;node&apos;], from: &apos;&apos;&#125;)&apos;name=scott&amp;course=jade&amp;course=node&amp;from=&apos;&gt; querystring.stringify(&#123;name:&apos;scott&apos;, course:[&apos;jade&apos;,&apos;node&apos;], from: &apos;&apos;&#125;, &apos;,&apos;)&apos;name=scott,course=jade,course=node,from=&apos;&gt; querystring.stringify(&#123;name:&apos;scott&apos;, course:[&apos;jade&apos;,&apos;node&apos;], from: &apos;&apos;&#125;, &apos;,&apos;,&apos;:&apos;)&apos;name:scott,course:jade,course:node,from:&apos; 参数反序列化querystring.parse(‘’, 参数之间的连接符-默认为&amp;, key和value之间的符号-默认=)12&gt; querystring.parse(&apos;name=scott&amp;course=jade&amp;course=node&amp;from=&apos;)&#123; name: &apos;scott&apos;, course: [ &apos;jade&apos;, &apos;node&apos; ], from: &apos;&apos; &#125; 转义querystring.escape(str)12&gt; querystring.escape(&apos;&lt;哈哈&gt;&apos;)&apos;%3C%E5%93%88%E5%93%88%3E&apos; 反转义 querystring.unescape 12 &gt; querystring.unescape(&apos;%3C%E5%93%88%E5%93%88%3E&apos;)&apos;&lt;哈哈&gt;&apos; Http1.http客户端发起请求，创建端口2.http服务器在端口监听客户端的请求3.http服务器向客户端返回状态和内容 浏览器发起请求到步骤1.Chrome搜索自身的DNS缓存2.搜索操作系统的DNS缓存3.读取本地的Host文件4.浏览器发起一个DNS一个系统调用（向运营商发起，下面小节步骤）5.浏览器获得域名对应的IP地址后，发起HTTP的三次握手6.TCP/IP连接建立起来后，浏览器就可以向服务器发送HTTP请求了7.服务器端接受到这个请求，根据路径参数，经过后端处理后，把处理后的一个结果的数据返回给浏览器8.浏览器获取到目标网址的数据，例如返回一个HTML文件,HTML文档内的JS/CSS/图片静态资源同样也是一个个HTTP请求，也要包括上述步骤9.浏览器根据获取到的资源对页面进行渲染，最终把网页呈献给用户 运营商的DNS服务器1.宽带运营商服务器查看本身缓存2.运营商服务器代替浏览器发起一个迭代的DNS解析请求，运营商服务器把结果返回给操作系统内核同时缓存起来，操作系统内核把结果返回给浏览器 http头和正文信息HTTP头发送的是一些附加的信息：内容类型、服务器发送相应的日期、HTTP状态码。正文就是用户提交的表单数据。 1、什么是回调函数？回调是异步编程时的基础，将后续逻辑封装成起始函数的参数，逐层嵌套2、什么事同步/异步？同步：发送方发送数据后，等待接收方发回响应以后才发下一个数据包的通讯方式异步：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式3、什么事I/O?文件系统里面 磁盘的写入（in）磁盘的读取（out）4、什么是单线程/多线程？一次只能执行一个程序叫做单线程一次能执行多个程序叫做多线程5、什么是阻塞/非阻塞？阻塞：前一个程序未执行完就得一直等待非阻塞：前一个程序未执行完时可以挂起，继续执行其他程序，等到使用时再执行6、什么是事件？一个触发动作（例如点击按钮）7、什么是事件驱动？一个触发动作引起的操作（例如点击按钮后弹出一个对话框）8、什么是基于事件驱动的回调？为了某个事件注册了回调函数，但是这个回调函数不是马上执行，只有当事件发生的时候，才会调用回掉函数，这种函数执行的方式叫做事件驱动~这种注册回掉就是基于事件驱动的回调，如果这些回调和异步I/O（数据写入、读取）操作相关，可以看作是基于回调的异步I/O。只不过这种回调在nodejs中是由事件来驱动的9、什么是事件循环？事件循环Eventloop，倘若有大量的异步操作，如一些I/O的耗时操作，甚至是一些定时器控制的延时操作，它们完成的时候都要调用相应的回调函数，而从完成一些密集的任务，而又不会阻塞整个程序执行的流程，此时需要一种机制来管理，这种机制叫做事件循环总而言之，管理大量异步操作的机制叫做事件循环 作用域和上下文作用域：与调用函数,访问变量的能力有关 作用域分为：局部和全局（在局部作用域里可以访问到全局作用域的变量，但在局部作用域外面就访问不到局部作用里面所设定的变量） 上下文：与this关键字有关 是调用当前可执行代码的引用 this总是指向调用这个的方法的对象js里的this 通常是当前函数的拥有者this 是js的一个关键字 代表函数运行时自动生成的一个内部对象 只能在函数内部使用 1.作为对象的方法this在方法内部，this就指向调用这个方法的对象123456789var pet = &#123; words: '...', speak: function() &#123; console.log(this.words); console.log(pet===this); &#125;&#125;pet.speak(); 2.函数的调用this指向执行环境中的全局对象（浏览器-&gt;window nodejs-&gt;global）12345678function pets(words) &#123; this.words = words; console.log(this.words); console.log(this); console.log(this===global);&#125;pets('...'); 3.构造函数this所在的方法被实例对象所调用，那么this就指向这个实例对象12345678910function petss(words) &#123; this.words = words; this.speak = function() &#123; console.log(this.words); console.log(this); &#125;&#125;var cat = new petss('miao');cat.speak(); 更改上下文方法(更改this指向的内容,可方便地实现继承)： call(list); 1234567891011var pet = &#123; words: '...', speak: function(say) &#123; console.log(say + ' ' + this.words); &#125;&#125;var dog = &#123; words: 'wang'&#125;//通过使用call方法，将pet的上下文指向为dog内部pet.speak.call(dog, 'Speak'); apply(array);根据call()、apply()改变上下文this指向的特性,也可以方便实现继承。 1234567891011121314function Pet(words) &#123; this.words = words; this.speak = function() &#123; console.log(this.words); &#125;&#125;function Dog(words) &#123; Pet.call(this, words); //Pet.apply(this. arguments);&#125;var dog = new Dog('wang');dog.speak(); 事件Eventsa.EventEmitter支持多个事件监听，最大为10，也可以自定义最大数1234//添加监听var EventEmitter = require('events').EventEmitter;var instance = new EventEmitter();instance.on('event',function(arguments)&#123;&#125;); b.如果超过十个也能执行，不过有可能会造成内存泄漏123//自定义最大数//每个setMaxListeners针对的是一个特定事件：即event1,event2,... 默认最大都为10,本例为numinstance.setMaxListeners(num); c.事件监听之后，需要emit(发射,发出)才会执行 1instance.emit('event',arguments) d.判断是否监听12var a = instance.emit('event',arguments) console.log(a) //打印出来的是布尔值true or false e.移除监听事件123456//移除单个事件监听instance.removeListener('event',funcName) //移除事件需具名函数，匿名函数不行//移除多个事件监听instance.removeAllListerner() //不传参表示移除所有事件监听instance.removeAllListerner('event') //移除特定event的所有事件监听 f.计算事件监听数量12345//第一种instance.listeners('event').length//第二种EventEmitter.listenerCount(instance,'event') Http请求的性能测试1.如果没有安装Apache的话，首先要安装Apache。2.mac直接在终端命令行中运行命令 ab -n1000 -c10 http://localhost:2017/ 即测试本地服务的性能。1234567var http = require('http');http.createServer(function(req, res) &#123; res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); res.write('Hello nodejs'); res.end();&#125;).listen(2017) 3.ab -n1000 -c10 url 即测试任意url的性能-n1000 总请求数1000 默认值1-c10 并发数10 默认值1-t 测试的时间-p post数据文件 ##小实践http小爬虫12345678910111213141516171819202122232425262728293031323334var http = require('http');var url = 'http://www.imooc.com/learn/901';var cheerio = require('cheerio');function filterChapters(html)&#123; var $ = cheerio.load(html); var chapters = $('.learnChapter'); var courseData = []; chapters.each(function(item)&#123; var chapter = $(this); var chapterTitle = chapter.find('strong').text(); var videos = chapter.find('.video').children('li'); var chapterData = &#123; chapterTitle: chapterTitle, videos: [] &#125; videos.each(function(item)&#123; var video = $(this).find('.studyvedio'); var videoTitle = video.text(); var id = video.attr('href').split('video/')[1]; chapterData.videos.push(&#123;title: videoTitle,id: id&#125;); &#125;); courseData.push(chapterData); &#125;); return courseData;&#125;function printCourseInfo(courseData)&#123; courseData.forEach(function(item)&#123; var chapterTitle = item.chapterTitle; console.log(chapterTitle + '\n'); item.videos.forEach(function(video)&#123; console.log('[' + video.id + ']' + video.title + '\n'); &#125;); &#125;);&#125; 评论灌水1234567891011121314151617181920212223242526272829var http =require('http');var querystring =require('querystring');var postData = querystring.stringify(&#123; 'content':'小路人注水测试评论', 'mid':8837&#125;);var options=&#123; hostname : 'www.imooc.com', port:80, path:'/course/docomment', method:'POST', headers:&#123;消息头&#125;);var req=http.request(options ,function (res)&#123; console.log('Status: '+res.statusCode); console.log('headers: '+JSON.stringify(res.headers)); res.on('data',function(chunk)&#123; console.log(Buffer.isBuffer(chunk)); console.log(typeof chunk); &#125;); res.on('end',function()&#123; console.log('小路人注水评论完毕！'); &#125;);&#125;);req.on('error',function(e)&#123; console.log('Error: '+e.message);&#125;);req.write(postData);req.end();]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap]]></title>
    <url>%2F2017%2F09%2F18%2Fboostrap%2F</url>
    <content type="text"><![CDATA[本文主要介绍了Boostrap的全局样式和常用组件。 Bootstrap的特性 响应式设计 栅格布局 完整的类库 JQuery插件 不同的使用场景 从Hello world开始程序员学习一门语言，第一个例子一定是著名的Hello world，那么，我们先来准备一个Hello world吧！首先，到Bootstrap中文网下载用于生产环境的Bootstrap。Bootstrap 提供了两种形式的压缩包，在下载下来的压缩包内可以看到以下目录和文件，这些文件按照类别放到了不同的目录内，并且提供了压缩与未压缩两种版本。 Bootstrap 插件全部依赖 jQuery请注意，Bootstrap 的所有 JavaScript 插件都依赖 jQuery，因此 jQuery 必须在 Bootstrap 之前引入，就像在基本模版中所展示的一样。在 bower.json 文件中 列出了 Bootstrap 所支持的 jQuery 版本。 下载压缩包之后，将其解压缩到任意目录即可看到以下（压缩版的）目录结构：12345678910111213141516171819bootstrap/├── css/│ ├── bootstrap.css│ ├── bootstrap.css.map│ ├── bootstrap.min.css│ ├── bootstrap.min.css.map│ ├── bootstrap-theme.css│ ├── bootstrap-theme.css.map│ ├── bootstrap-theme.min.css│ └── bootstrap-theme.min.css.map├── js/│ ├── bootstrap.js│ └── bootstrap.min.js└── fonts/ ├── glyphicons-halflings-regular.eot ├── glyphicons-halflings-regular.svg ├── glyphicons-halflings-regular.ttf ├── glyphicons-halflings-regular.woff └── glyphicons-halflings-regular.woff2 可以直接引用bootstrap的预编译文件，但是要注意的是，Bootstrap是要依赖JQuery的，因此，需要在引用Bootstrap的js之前引用JQuery。这里使用的是Bootstrap3，需要使用的JQuery版本需要高于1.3。 这样，就完成了我们的第一个例子–Hello world123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Bootstrap&lt;/title&gt; &lt;link rel="stylesheet" href="./css/bootstrap-theme.min.css"&gt; &lt;script src="./js/jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;script src="./js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button class="btn btn-info"&gt;hello world&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 这里要强调的是，Bootstrap 使用到的某些 HTML 元素和 CSS 属性需要将页面设置为 HTML5 文档类型。在你项目中的每个页面都要参照下面的格式进行设置。1234&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt; ...&lt;/html&gt; 另外，Bootdtrap是移动设备优先的，针对移动设备的样式融合进了框架的每个角落，而不是增加一个额外的文件。为了确保适当的绘制和触屏缩放，需要在 head标签 之中添加 viewport 元数据标签。1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 全局样式传统前端开发过程中的问题： 重复，复杂，无意义的命名 结构冗余，胡乱嵌套 页面错乱 Bootstrap全局样式的特点： 代码整洁 风格统一 美观易用 栅格系统通过一系列行（row）和列（column）的组合来创建页面布局。工作原理 “行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。 通过“行（row）”在水平方向创建一组“列（column）”。 你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。 类似 .row 和 .col-xs-4 这种预定义的类，可以用来快速创建栅格布局。 通过为“列（column）”设置 padding 属性，从而创建列与列之间的间隔（gutter）。通过为 .row 元素设置负值 margin 从而抵消掉为 .container 元素设置的 padding，也就间接为“行（row）”所包含的“列（column）”抵消掉了padding。 负值的 margin就是下面的示例为什么是向外突出的原因。在栅格列中的内容排成一行。 栅格系统中的列是通过指定1到12的值来表示其跨越的范围。例如，三个等宽的列可以使用三个 .col-xs-4 来创建。 如果一“行（row）”中包含了的“列（column）”大于 12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列。 栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-md- 栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-lg- 不存在， 也影响大屏幕设备。 12345678/* 超小屏幕（手机，小于 768px） *//* 没有任何媒体查询相关的代码，因为这在 Bootstrap 中是默认的（还记得 Bootstrap 是移动设备优先的吗？） *//* 小屏幕（平板，大于等于 768px） */@media (min-width: @screen-sm-min) &#123; ... &#125;/* 中等屏幕（桌面显示器，大于等于 992px） */@media (min-width: @screen-md-min) &#123; ... &#125;/* 大屏幕（大桌面显示器，大于等于 1200px） */@media (min-width: @screen-lg-min) &#123; ... &#125; 水平布局使用单一的一组 .col-md-* 栅格类，就可以创建一个基本的栅格系统，在手机和平板设备上一开始是堆叠在一起的（超小屏幕到小屏幕这一范围），在桌面（中等）屏幕设备上变为水平排列。所有“列（column）必须放在 ” .row内。将最外面的布局元素 .container 修改为 .container-fluid，就可以将固定宽度的栅格布局转换为 100% 宽度的布局。123456789101112131415161718192021222324252627&lt;div class="row"&gt; &lt;div class="col-md-1"&gt;.col-md-1&lt;/div&gt; &lt;div class="col-md-1"&gt;.col-md-1&lt;/div&gt; &lt;div class="col-md-1"&gt;.col-md-1&lt;/div&gt; &lt;div class="col-md-1"&gt;.col-md-1&lt;/div&gt; &lt;div class="col-md-1"&gt;.col-md-1&lt;/div&gt; &lt;div class="col-md-1"&gt;.col-md-1&lt;/div&gt; &lt;div class="col-md-1"&gt;.col-md-1&lt;/div&gt; &lt;div class="col-md-1"&gt;.col-md-1&lt;/div&gt; &lt;div class="col-md-1"&gt;.col-md-1&lt;/div&gt; &lt;div class="col-md-1"&gt;.col-md-1&lt;/div&gt; &lt;div class="col-md-1"&gt;.col-md-1&lt;/div&gt; &lt;div class="col-md-1"&gt;.col-md-1&lt;/div&gt;&lt;/div&gt;&lt;div class="row"&gt; &lt;div class="col-md-8"&gt;.col-md-8&lt;/div&gt; &lt;div class="col-md-4"&gt;.col-md-4&lt;/div&gt;&lt;/div&gt;&lt;div class="row"&gt; &lt;div class="col-md-4"&gt;.col-md-4&lt;/div&gt; &lt;div class="col-md-4"&gt;.col-md-4&lt;/div&gt; &lt;div class="col-md-4"&gt;.col-md-4&lt;/div&gt;&lt;/div&gt;&lt;div class="row"&gt; &lt;div class="col-md-6"&gt;.col-md-6&lt;/div&gt; &lt;div class="col-md-6"&gt;.col-md-6&lt;/div&gt;&lt;/div&gt; 如果希望在小屏幕设备上列也不要堆叠在一起，可以使用针对超小屏幕定义大类.col-xs-和为中等屏幕定义的类.col-md-，针对平板设备则是用.col-sm-* 这个类。 如果在一个 .row 内包含的列（column）大于12个，包含多余列（column）的元素将作为一个整体单元被另起一行排列。 列偏移使用 .col-md-offset- 类可以将列向右侧偏移。这些类实际是通过使用 选择器为当前元素增加了左侧的边距（margin）。例如，.col-md-offset-4 类将 .col-md-4 元素向右侧偏移了4个列（column）的宽度。 嵌套列为了使用内置的栅格系统将内容再次嵌套，可以通过添加一个新的 .row 元素和一系列 .col-sm- 元素到已经存在的 .col-sm- 元素内。被嵌套的行（row）所包含的列（column）的个数不能超过12（其实，没有要求你必须占满12列）。12345678910111213&lt;div class="row"&gt; &lt;div class="col-sm-9"&gt; Level 1: .col-sm-9 &lt;div class="row"&gt; &lt;div class="col-xs-8 col-sm-6"&gt; Level 2: .col-xs-8 .col-sm-6 &lt;/div&gt; &lt;div class="col-xs-4 col-sm-6"&gt; Level 2: .col-xs-4 .col-sm-6 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 列排序通过使用 .col-md-push- 和 .col-md-pull- 类就可以很容易的改变列（column）的顺序。—应用不多 排版基本全局样式Bootstrap 排版、链接样式设置了基本的全局样式。分别是： 为 body 元素设置 background-color: #fff; 使用 @font-family-base、@font-size-base 和 @line-height-base 变量作为排版的基本参数; 为所有链接设置了基本颜色 @link-color ，并且当链接处于 :hover 状态时才添加下划线。 标题标题（h1~h6/.h1~.h6） h1:36px, h2:30px, h3:24px, h4:18px, h5:14px, h6: 12px副标题（small） 在body标签中输入下面的代码：123456789101112&lt;h1&gt;标题&lt;small&gt;小标题&lt;/small&gt;&lt;/h1&gt;&lt;h2&gt;标题&lt;/h2&gt;&lt;h3&gt;标题&lt;/h3&gt;&lt;h4&gt;标题&lt;/h4&gt;&lt;h5&gt;标题&lt;/h5&gt;&lt;h6&gt;标题&lt;/h6&gt;&lt;span class="h1"&gt;标题&lt;/span&gt;&lt;span class="h2"&gt;标题&lt;/span&gt;&lt;span class="h3"&gt;标题&lt;/span&gt;&lt;span class="h4"&gt;标题&lt;/span&gt;&lt;span class="h5"&gt;标题&lt;/span&gt;&lt;span class="h6"&gt;标题&lt;/span&gt; 可以看到在span中也可以使用标题的字体。 文本Bootstrap将全局的字号设置为14px，行高为1.428。并给段落（P标签）定义了初始的样式，默认14px，行高20px，底部间距10px。而普通网页中的段落字体大小默认为16px。可以通过mark标签实现对文本的黄底显示，通过del标签实现删除线,通过ins或者u实现下划线效果。通过small文字变小，strong文字加粗，em实现斜体。。。这些都是html5中的标签，只不过Bootstrap对样式进行了封装。另外，可以通过添加 .lead 类可以让段落突出显示。12&lt;p&gt;测试一下段落&lt;mark&gt;打个马&lt;/mark&gt;&lt;del&gt;删除&lt;/del&gt;&lt;ins&gt;插入文本下划线效果&lt;/ins&gt;&lt;/p&gt;&lt;p&gt;测试一下段落&lt;/p&gt; 效果图： 对齐靠左对齐 .text-left居中对齐 .text-center靠右对齐 .text-right 大小写大写转小写 .text-lowercase小写转大写 .text-uppercase首字母大写 .text-capitalize 缩略语当鼠标悬停在缩写和缩写词上时就会显示完整内容，Bootstrap 实现了对 HTML 的 元素的增强样式。缩略语元素带有 title 属性，外观表现为带有较浅的虚线框，鼠标移至上面时会变成带有“问号”的指针。如想看完整的内容可把鼠标悬停在缩略语上（对使用辅助技术的用户也可见）, 但需要包含 title 属性。为缩略语添加 .initialism 类，可以让 font-size 变得稍微小些。1&lt;abbr title="HyperText Markup Language" class="initialism"&gt;HTML&lt;/abbr&gt; 引用1234&lt;blockquote&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante.&lt;/p&gt; &lt;footer&gt;Someone famous in &lt;cite title="Source Title"&gt;Source Title&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt; 通过赋予 .blockquote-reverse 类可以让引用呈现内容右对齐的效果。 列表列表分为无序列表(ul)和有序liebiao(ol)两种，默认具有list-style样式，即子元素li为逐行展示,可以通过设置 display: inline-block; 并添加少量的内补（padding），将所有元素放置于同一行。另外还有一种带有描述的短语列表，可以通过dl实现，其中dt为短语，dd为描述内容。.dl-horizontal 可以让dl 内的短语及其描述排在一行。开始是像 dl 的默认样式堆叠在一起，随着导航条逐渐展开而排列在一行。 代码内联代码通过 &lt;code&gt; 标签包裹内联样式的代码片段。用户输入通过 &lt;kbd&gt; 标签标记用户通过键盘输入的内容。代码块多行代码可以使用 &lt;pre&gt; 标签。还可以使用 .pre-scrollable 类，其作用是设置 max-height 为 350px ，并在垂直方向展示滚动条。变量通过 &lt;var&gt; 标签标记变量。程序输出通过 &lt;samp&gt; 标签来标记程序输出的内容。 表格表格 table带边框的表格 .table-bordered条纹状表格 .table-striped悬停变色 .table-hover紧凑风格 .table-condensed .active 鼠标悬停在行或单元格上时所设置的颜色 .success 标识成功或积极的动作 .info 标识普通的提示信息或动作 .warning 标识警告或需要用户注意 .danger 标识危险或潜在的带来负面影响的动作 响应式将任何 .table 元素包裹在 .table-responsive 元素内，即可创建响应式表格，其会在小屏幕设备上（小于768px）水平滚动。当屏幕大于 768px 宽度时，水平滚动条消失。 表单Bootstrap给HTML大部分表单都设置了默认样式，我们可以给表单添加相应类名，以实现表单的水平排列和个性化定制。 所有设置了 .form-control 类的 &lt;input&gt;、&lt;textarea&gt; 和 &lt;select&gt; 元素都将被默认设置宽度属性为 width: 100%;。 将 label 元素和前面提到的控件包裹在 .form-group 中可以获得最好的排列。 每个&lt;form&gt;标签为一套表单，每个.form-group类为一个表单组，包含一个标签合一个表单元素。12345678910111213141516171819202122&lt;form&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputEmail1"&gt;Email address&lt;/label&gt; &lt;input type="email" class="form-control" id="exampleInputEmail1" placeholder="Email"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputPassword1"&gt;Password&lt;/label&gt; &lt;input type="password" class="form-control" id="exampleInputPassword1" placeholder="Password"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputFile"&gt;File input&lt;/label&gt; &lt;input type="file" id="exampleInputFile"&gt; &lt;p class="help-block"&gt;Example block-level help text here.&lt;/p&gt; &lt;/div&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox"&gt; Check me out &lt;/label&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt;&lt;/form&gt; 为 &lt;form&gt; 元素添加 .form-inline 类可使其内容左对齐并且表现为 inline-block 级别的控件。只适用于视口（viewport）至少在 768px 宽度时（视口宽度再小的话就会使表单折叠）。 1234567891011&lt;form class="form-inline"&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputName2"&gt;Name&lt;/label&gt; &lt;input type="text" class="form-control" id="exampleInputName2" placeholder="Jane Doe"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputEmail2"&gt;Email&lt;/label&gt; &lt;input type="email" class="form-control" id="exampleInputEmail2" placeholder="jane.doe@example.com"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;Send invitation&lt;/button&gt;&lt;/form&gt; 如果你没有为每个输入控件设置 label 标签，屏幕阅读器将无法正确识别。对于这些内联表单，你可以通过为 label 设置 .sr-only 类将其隐藏。还有一些辅助技术提供label标签的替代方案，比如 aria-label、aria-labelledby 或 title 属性。如果这些都不存在，屏幕阅读器可能会采取使用 placeholder 属性，如果存在的话，使用占位符来替代其他的标记，但要注意，这种方法是不妥当的。 12345678910111213141516&lt;form class="form-inline"&gt; &lt;div class="form-group"&gt; &lt;label class="sr-only" for="exampleInputEmail3"&gt;Email address&lt;/label&gt; &lt;input type="email" class="form-control" id="exampleInputEmail3" placeholder="Email"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label class="sr-only" for="exampleInputPassword3"&gt;Password&lt;/label&gt; &lt;input type="password" class="form-control" id="exampleInputPassword3" placeholder="Password"&gt; &lt;/div&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox"&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;Sign in&lt;/button&gt;&lt;/form&gt; 通过为表单添加 .form-horizontal 类，并联合使用 Bootstrap 预置的栅格类，可以将 label 标签和控件组水平并排布局。这样做将改变 .form-group 的行为，使其表现为栅格系统中的行（row），因此就无需再额外添加 .row 了。 12345678910111213141516171819202122232425262728&lt;form class="form-horizontal"&gt; &lt;div class="form-group"&gt; &lt;label for="inputEmail3" class="col-sm-2 control-label"&gt;Email&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="email" class="form-control" id="inputEmail3" placeholder="Email"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="inputPassword3" class="col-sm-2 control-label"&gt;Password&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="password" class="form-control" id="inputPassword3" placeholder="Password"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-sm-offset-2 col-sm-10"&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox"&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-sm-offset-2 col-sm-10"&gt; &lt;button type="submit" class="btn btn-default"&gt;Sign in&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 支持的控件1.输入框–input包括大部分表单控件、文本输入域控件，还支持所有 HTML5 类型的输入控件： text、password、datetime、datetime-local、date、month、time、week、number、email、url、search、tel 和 color。 只有正确设置了 type 属性的输入控件才能被赋予正确的样式。 2.文本域–textarea支持多行文本的表单控件。可根据需要改变 rows 属性。 3.单选和多选单选框和多选框的默认外观是纵向堆叠在一起的。通过将 .checkbox-inline 或 .radio-inline 类应用到一系列的多选框（checkbox）或单选框（radio）控件上，可以使这些控件排列在一行。12345678910111213141516171819&lt;label class="checkbox-inline"&gt; &lt;input type="checkbox" id="inlineCheckbox1" value="option1"&gt; 1&lt;/label&gt;&lt;label class="checkbox-inline"&gt; &lt;input type="checkbox" id="inlineCheckbox2" value="option2"&gt; 2&lt;/label&gt;&lt;label class="checkbox-inline"&gt; &lt;input type="checkbox" id="inlineCheckbox3" value="option3"&gt; 3&lt;/label&gt;&lt;label class="radio-inline"&gt; &lt;input type="radio" name="inlineRadioOptions" id="inlineRadio1" value="option1"&gt; 1&lt;/label&gt;&lt;label class="radio-inline"&gt; &lt;input type="radio" name="inlineRadioOptions" id="inlineRadio2" value="option2"&gt; 2&lt;/label&gt;&lt;label class="radio-inline"&gt; &lt;input type="radio" name="inlineRadioOptions" id="inlineRadio3" value="option3"&gt; 3&lt;/label&gt; 如果需要 内没有文字，输入框（input）正是你所期望的。 目前只适用于非内联的 checkbox 和 radio。 请记住，仍然需要为使用辅助技术的用户提供某种形式的 label（例如，使用 aria-label）。aria-label=”…” 4.下拉列表对于标记了 multiple 属性的 &lt;select&gt; 控件来说，默认显示多选项。 静态控件如果需要在表单中将一行纯文本和 &lt;label&gt; 元素放置于同一行，为 &lt;p&gt; 元素添加 .form-control-static 类即可。12345678&lt;form class="form-horizontal"&gt; &lt;div class="form-group"&gt; &lt;label class="col-sm-2 control-label"&gt;Email&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;p class="form-control-static"&gt;email@example.com&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 表单控件后面友好的帮助信息可以在&lt;span&gt;标签中增加.help-block类名。 校验状态Bootstrap 对表单控件的校验状态，如 error、warning 和 success 状态，都定义了样式。使用时，添加 .has-warning、.has-error 或 .has-success 类到这些控件的父元素即可。任何包含在此元素之内的 .control-label、.form-control 和 .help-block 元素都将接受这些校验状态的样式。 在表单输入区域内添加额外的图标你还可以针对校验状态为输入框添加额外的图标。只需设置相应的 .has-feedback 类并添加正确的图标即可。123456789101112131415161718192021222324252627&lt;div class="form-group has-success has-feedback"&gt; &lt;label class="control-label" for="inputSuccess2"&gt;Input with success&lt;/label&gt; &lt;input type="text" class="form-control" id="inputSuccess2" aria-describedby="inputSuccess2Status"&gt; &lt;span class="glyphicon glyphicon-ok form-control-feedback" aria-hidden="true"&gt;&lt;/span&gt; &lt;span id="inputSuccess2Status" class="sr-only"&gt;(success)&lt;/span&gt; &lt;/div&gt;&lt;div class="form-group has-warning has-feedback"&gt; &lt;label class="control-label" for="inputWarning2"&gt;Input with warning&lt;/label&gt; &lt;input type="text" class="form-control" id="inputWarning2" aria-describedby="inputWarning2Status"&gt; &lt;span class="glyphicon glyphicon-warning-sign form-control-feedback" aria-hidden="true"&gt;&lt;/span&gt; &lt;span id="inputWarning2Status" class="sr-only"&gt;(warning)&lt;/span&gt;&lt;/div&gt;&lt;div class="form-group has-error has-feedback"&gt; &lt;label class="control-label" for="inputError2"&gt;Input with error&lt;/label&gt; &lt;input type="text" class="form-control" id="inputError2" aria-describedby="inputError2Status"&gt; &lt;span class="glyphicon glyphicon-remove form-control-feedback" aria-hidden="true"&gt;&lt;/span&gt; &lt;span id="inputError2Status" class="sr-only"&gt;(error)&lt;/span&gt;&lt;/div&gt;&lt;div class="form-group has-success has-feedback"&gt; &lt;label class="control-label" for="inputGroupSuccess1"&gt;Input group with success&lt;/label&gt; &lt;div class="input-group"&gt; &lt;span class="input-group-addon"&gt;@&lt;/span&gt; &lt;input type="text" class="form-control" id="inputGroupSuccess1" aria-describedby="inputGroupSuccess1Status"&gt; &lt;/div&gt; &lt;span class="glyphicon glyphicon-ok form-control-feedback" aria-hidden="true"&gt;&lt;/span&gt; &lt;span id="inputGroupSuccess1Status" class="sr-only"&gt;(success)&lt;/span&gt;&lt;/div&gt; 控件尺寸通过 .input-lg 类似的类可以为控件设置高度，通过 .col-lg- 类似的类可以为控件设置宽度。大号 .input-lg小号 .input-sm通过添加 .form-group-lg 或 .form-group-sm 类，为 .form-horizontal 包裹的 label 元素和表单控件快速设置尺寸用栅格系统中的列（column）包裹输入框或其任何父元素，都可很容易的为其设置宽度。.col-xs- 按钮1234567&lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt;&lt;button type="submit" class="btn btn-success"&gt;Submit&lt;/button&gt;&lt;button type="submit" class="btn btn-warning"&gt;Submit&lt;/button&gt;&lt;button type="submit" class="btn btn-primary"&gt;Submit&lt;/button&gt;&lt;button type="submit" class="btn btn-info"&gt;Submit&lt;/button&gt;&lt;button type="submit" class="btn btn-danger"&gt;Submit&lt;/button&gt;&lt;button type="submit" class="btn btn-link"&gt;Submit&lt;/button&gt; 需要让按钮具有不同尺寸吗？使用 .btn-lg、.btn-sm 或 .btn-xs 就可以获得不同尺寸的按钮。通过给按钮添加 .btn-block 类可以将其拉伸至父元素100%的宽度，而且按钮也变为了块级（block）元素。 响应式图片在 Bootstrap 版本 3 中，通过为图片添加 .img-responsive 类可以让图片支持响应式布局。如果需要让使用了 .img-responsive 类的图片水平居中，请使用 .center-block 类。修改图片形状123&lt;img src="..." alt="..." class="img-rounded"&gt;&lt;img src="..." alt="..." class="img-circle"&gt;&lt;img src="..." alt="..." class="img-thumbnail"&gt; 可用的类123.visible-*-block.visible-*-inline.visible-*-inline-block 辅助类文本颜色123456&lt;p class="text-muted"&gt;...&lt;/p&gt;&lt;p class="text-primary"&gt;...&lt;/p&gt;&lt;p class="text-success"&gt;...&lt;/p&gt;&lt;p class="text-info"&gt;...&lt;/p&gt;&lt;p class="text-warning"&gt;...&lt;/p&gt;&lt;p class="text-danger"&gt;...&lt;/p&gt; 背景色12345&lt;p class="bg-primary"&gt;...&lt;/p&gt;&lt;p class="bg-success"&gt;...&lt;/p&gt;&lt;p class="bg-info"&gt;...&lt;/p&gt;&lt;p class="bg-warning"&gt;...&lt;/p&gt;&lt;p class="bg-danger"&gt;...&lt;/p&gt; 关闭模态框和警告框1&lt;button type="button" class="close" aria-label="Close"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; 三角下拉图标1&lt;span class="caret"&gt;&lt;/span&gt; 快速浮动12&lt;div class="pull-left"&gt;...&lt;/div&gt;&lt;div class="pull-right"&gt;...&lt;/div&gt; 让内容块居中1&lt;div class="center-block"&gt;...&lt;/div&gt; 清除浮动1&lt;div class="clearfix"&gt;...&lt;/div&gt; 显示或隐藏内容12&lt;div class="show"&gt;...&lt;/div&gt;&lt;div class="hidden"&gt;...&lt;/div&gt; 组件下拉菜单将下拉菜单触发器和下拉菜单都包裹在 .dropdown 里，或者另一个声明了 position: relative; 的元素。然后加入组成菜单的 HTML 代码。通过为下拉菜单的父元素设置 .dropup 类，可以让菜单向上弹出（默认是向下弹出的）。12345678910111213&lt;div class="dropdown"&gt; &lt;button class="btn btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"&gt; Dropdown &lt;span class="caret"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class="dropdown-menu" aria-labelledby="dropdownMenu1"&gt; &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt;&lt;!--分割线 --&gt; &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 为 .dropdown-menu 添加 .dropdown-menu-right 类可以让菜单右对齐。123&lt;ul class="dropdown-menu dropdown-menu-right" aria-labelledby="dLabel"&gt; ...&lt;/ul&gt; 为下拉菜单中的 li 元素添加 .disabled 类，可以禁用相应的菜单项。 按钮组通过按钮组容器.btn-group把一组按钮放在同一行里。让一组按钮垂直堆叠排列显示而不是水平排列.btn-group-vertical让一组按钮拉长为相同的尺寸，填满父元素的宽度.btn-group-justified把一组 .btn-group 组合进一个 .btn-toolbar 中就可以做成更复杂的组件。123456789&lt;div class="btn-toolbar" role="toolbar" aria-label="..."&gt; &lt;div class="btn-group" role="group" aria-label="..."&gt; &lt;button type="button" class="btn btn-default"&gt;Left&lt;/button&gt; &lt;button type="button" class="btn btn-default"&gt;Middle&lt;/button&gt; &lt;button type="button" class="btn btn-default"&gt;Right&lt;/button&gt; &lt;/div&gt; &lt;div class="btn-group" role="group" aria-label="..."&gt;...&lt;/div&gt; &lt;div class="btn-group" role="group" aria-label="..."&gt;...&lt;/div&gt;&lt;/div&gt; 按钮组修改尺寸：1234&lt;div class="btn-group btn-group-lg" role="group" aria-label="..."&gt;...&lt;/div&gt;&lt;div class="btn-group" role="group" aria-label="..."&gt;...&lt;/div&gt;&lt;div class="btn-group btn-group-sm" role="group" aria-label="..."&gt;...&lt;/div&gt;&lt;div class="btn-group btn-group-xs" role="group" aria-label="..."&gt;...&lt;/div&gt; 想要把下拉菜单混合到一系列按钮中，只须把 .btn-group 放入另一个 .btn-group 中。123456789101112131415&lt;div class="btn-group" role="group" aria-label="..."&gt; &lt;button type="button" class="btn btn-default"&gt;1&lt;/button&gt; &lt;button type="button" class="btn btn-default"&gt;2&lt;/button&gt; &lt;div class="btn-group" role="group"&gt; &lt;button type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"&gt; Dropdown &lt;span class="caret"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#"&gt;Dropdown link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Dropdown link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 按钮式下拉菜单单按钮下拉菜单12345678910111213&lt;!-- Single button --&gt;&lt;div class="btn-group"&gt; &lt;button type="button" class="btn btn-success dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"&gt; Action &lt;span class="caret"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 分裂式按钮下拉菜单123456789101112131415&lt;!-- Split button --&gt;&lt;div class="btn-group"&gt; &lt;button type="button" class="btn btn-danger"&gt;Action&lt;/button&gt; &lt;button type="button" class="btn btn-danger dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"&gt; &lt;span class="caret"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Toggle Dropdown&lt;/span&gt; &lt;/button&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 给父元素添加 .dropup 类就能使触发的下拉菜单朝上方打开。尺寸123.btn-lg.btn-sm.btn-xs 输入框组通过在文本输入框 input 前面、后面或是两边加上文字或按钮，可以实现对表单控件的扩展。为 .input-group 赋予 .input-group-addon 或 .input-group-btn 类，可以给 .form-control 的前面或后面添加额外的元素。可以将多选框，单选框，按钮，按钮式下拉菜单或分裂式按钮下拉菜单作为额外元素添加到输入框组中，使用.input-group-btn类包装。1234567891011&lt;div class="input-group"&gt; &lt;span class="input-group-addon"&gt;$&lt;/span&gt; &lt;input type="text" class="form-control" aria-label="Amount (to the nearest dollar)"&gt; &lt;span class="input-group-addon"&gt;.00&lt;/span&gt;&lt;/div&gt;&lt;label for="basic-url"&gt;Your vanity URL&lt;/label&gt;&lt;div class="input-group"&gt; &lt;span class="input-group-addon" id="basic-addon3"&gt;https://example.com/users/&lt;/span&gt; &lt;input type="text" class="form-control" id="basic-url" aria-describedby="basic-addon3"&gt;&lt;/div&gt; 尺寸123.input-group-lg.input-group-sm.input-group-xs 导航Bootstrap 中的导航组件都依赖同一个 .nav 类，状态类也是共用的。Tab标签页式导航： .nav-tabs12345&lt;ul class="nav nav-tabs"&gt; &lt;li role="presentation" class="active"&gt;&lt;a href="#"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a href="#"&gt;Profile&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a href="#"&gt;Messages&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 胶囊式标签页导航： .nav-pills，垂直堆叠只需添加 .nav-stacked 类12345&lt;ul class="nav nav-pills"&gt; &lt;li role="presentation" class="active"&gt;&lt;a href="#"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a href="#"&gt;Profile&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a href="#"&gt;Messages&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 在大于 768px 的屏幕上，通过 .nav-justified 类可以很容易的让标签页或胶囊式标签呈现出同等宽度。在小屏幕上，导航链接呈现堆叠样式。对任何导航组件（标签页、胶囊式标签页），都可以添加 .disabled 类，从而实现链接为灰色且没有鼠标悬停效果。 同样的，导航效果也可以添加下拉菜单，可以参照按钮下拉。 导航条导航条是在您的应用或网站中作为导航页头的响应式基础组件。它们在移动设备上可以折叠（并且可开可关），且在视口（viewport）宽度增加时逐渐变为水平展开模式。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;nav class="navbar navbar-default"&gt; &lt;div class="container-fluid"&gt; &lt;!--品牌图标--&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="#"&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;Link &lt;span class="sr-only"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"&gt;Dropdown &lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;One more separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!--表单--&gt; &lt;form class="navbar-form navbar-left"&gt; &lt;div class="form-group"&gt; &lt;input type="text" class="form-control" placeholder="Search"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;ul class="nav navbar-nav navbar-right"&gt; &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"&gt;Dropdown &lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt;&lt;/nav&gt; 品牌图标将导航条内放置品牌标志的地方替换为 img 元素即可展示自己的品牌图标。由于 .navbar-brand 已经被设置了内补（padding）和高度（height），你需要根据自己的情况添加一些 CSS 代码从而覆盖默认设置。 表单将表单放置于 .navbar-form 之内可以呈现很好的垂直对齐，并在较窄的视口（viewport）中呈现折叠状态。 使用对齐选项可以规定其在导航条上出现的位置。 按钮对于不包含在 form 中的 button 元素，加上 .navbar-btn 后，可以让它在导航条里垂直居中。 文本把文本包裹在 .navbar-text 中时，为了有正确的行距和颜色，通常使用 p 标签。1&lt;p class="navbar-text"&gt;Signed in as Mark Otto&lt;/p&gt; 非导航链接或许你希望在标准的导航组件之外添加标准链接，那么，使用 .navbar-link 类可以让链接有正确的默认颜色和反色设置。1&lt;p class="navbar-text navbar-right"&gt;Signed in as &lt;a href="#" class="navbar-link"&gt;Mark Otto&lt;/a&gt;&lt;/p&gt; 左右浮动通过添加 .navbar-left 和 .navbar-right 工具类让导航链接、表单、按钮或文本对齐。两个类都会通过 CSS 设置特定方向的浮动样式。 固定在顶部添加 .navbar-fixed-top 类可以让导航条固定在顶部，还可包含一个 .container 或 .container-fluid 容器，从而让导航条居中，并在两侧添加内补（padding）。 固定在底部添加 .navbar-fixed-bottom 类可以让导航条固定在底部，并且还可以包含一个 .container 或 .container-fluid 容器，从而让导航条居中，并在两侧添加内补（padding）。 静止在顶部通过添加 .navbar-static-top 类即可创建一个与页面等宽度的导航条，它会随着页面向下滚动而消失。还可以包含一个 .container 或 .container-fluid 容器，用于将导航条居中对齐并在两侧添加内补（padding）。 改变导航条颜色通过添加 .navbar-inverse 类可以改变导航条的外观。 路径导航(面包屑)在一个带有层次的导航结构中标明当前页面的位置。各路径间的分隔符已经自动通过 CSS 的 :before 和 content 属性添加了。12345&lt;ol class="breadcrumb"&gt; &lt;li&gt;&lt;a href="#"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Library&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;Data&lt;/li&gt;&lt;/ol&gt; 分页12345678910111213141516171819&lt;nav aria-label="Page navigation"&gt; &lt;ul class="pagination"&gt; &lt;li&gt; &lt;a href="#" aria-label="Previous"&gt; &lt;span aria-hidden="true"&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="#" aria-label="Next"&gt; &lt;span aria-hidden="true"&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 可以给不能点击的链接添加 .disabled 类、给当前页添加 .active 类。.pagination-lg 或 .pagination-sm 类提供了额外可供选择的尺寸，添加到 ul 标签。 上一页和下一页的简单翻页123456&lt;nav aria-label="..."&gt; &lt;ul class="pager"&gt; &lt;li&gt;&lt;a href="#"&gt;Previous&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Next&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 两端对齐123456&lt;nav aria-label="..."&gt; &lt;ul class="pager"&gt; &lt;li class="previous"&gt;&lt;a href="#"&gt;&lt;span aria-hidden="true"&gt;&amp;larr;&lt;/span&gt; Older&lt;/a&gt;&lt;/li&gt; &lt;li class="next"&gt;&lt;a href="#"&gt;Newer &lt;span aria-hidden="true"&gt;&amp;rarr;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 标签123456&lt;span class="label label-default"&gt;Default&lt;/span&gt;&lt;span class="label label-primary"&gt;Primary&lt;/span&gt;&lt;span class="label label-success"&gt;Success&lt;/span&gt;&lt;span class="label label-info"&gt;Info&lt;/span&gt;&lt;span class="label label-warning"&gt;Warning&lt;/span&gt;&lt;span class="label label-danger"&gt;Danger&lt;/span&gt; 数量标记给链接、导航等元素嵌套 &lt;span class=”badge”&gt; 元素，可以很醒目的展示新的或未读的信息条目。1234&lt;a href="#"&gt;Inbox &lt;span class="badge"&gt;42&lt;/span&gt;&lt;/a&gt;&lt;button class="btn btn-primary" type="button"&gt; Messages &lt;span class="badge"&gt;4&lt;/span&gt;&lt;/button&gt; 巨幕12345&lt;div class="jumbotron"&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;p&gt;bibibibibibibibibi&lt;/p&gt; &lt;p&gt;&lt;a class="btn btn-primary btn-lg" href="#" role="button"&gt;Learn more&lt;/a&gt;&lt;/p&gt;&lt;/div&gt; 缩略图123456789101112&lt;div class="row"&gt; &lt;div class="col-sm-6 col-md-4"&gt; &lt;div class="thumbnail"&gt; &lt;img src="..." alt="..."&gt; &lt;div class="caption"&gt; &lt;h3&gt;Thumbnail label&lt;/h3&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;&lt;a href="#" class="btn btn-primary" role="button"&gt;Button&lt;/a&gt; &lt;a href="#" class="btn btn-default" role="button"&gt;Button&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 警告框1234&lt;div class="alert alert-success" role="alert"&gt;...&lt;/div&gt;&lt;div class="alert alert-info" role="alert"&gt;...&lt;/div&gt;&lt;div class="alert alert-warning" role="alert"&gt;...&lt;/div&gt;&lt;div class="alert alert-danger" role="alert"&gt;...&lt;/div&gt; 为警告框添加一个可选的 .alert-dismissible 类和一个关闭按钮。1234&lt;div class="alert alert-warning alert-dismissible" role="alert"&gt; &lt;button type="button" class="close" data-dismiss="alert" aria-label="Close"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;strong&gt;Warning!&lt;/strong&gt; Better check yourself, you're not looking too good.&lt;/div&gt; 警告中的链接1&lt;a href="#" class="alert-link"&gt;...&lt;/a&gt; 进度条12345&lt;div class="progress"&gt; &lt;div class="progress-bar" role="progressbar" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100" style="width: 60%;"&gt; 60% &lt;/div&gt;&lt;/div&gt; 在展示很低的百分比时，如果需要让文本提示能够清晰可见，可以为进度条设置 min-width 属性。要展示不同效果都进度条1234&lt;div class=&quot;progress-bar progress-bar-success&quot;&lt;div class=&quot;progress-bar progress-bar-info&quot;&lt;div class=&quot;progress-bar progress-bar-warning&quot;&lt;div class=&quot;progress-bar progress-bar-danger&quot; 条纹效果类.progress-bar-striped为 .progress-bar-striped 添加 .active 类，使其呈现出由右向左运动的动画效果.把多个进度条放入同一个 .progress 中，使它们呈现堆叠的效果。 媒体对象123456789101112131415161718192021222324252627282930313233&lt;div class="media"&gt; &lt;div class="media-left media-middle"&gt; &lt;a href="#"&gt; &lt;img class="media-object" src="..." alt="..."&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class="media-body"&gt; &lt;h4 class="media-heading"&gt;Middle aligned media&lt;/h4&gt; Cras sit amet nibh libero, in gravida nulla. Nulla vel metus scelerisque ante sollicitudin commodo. Cras purus odio, vestibulum in vulputate at, tempus viverra turpis. Fusce condimentum nunc ac nisi vulputate fringilla. Donec lacinia congue felis in faucibus. &lt;/div&gt;&lt;/div&gt;&lt;div class="media"&gt; &lt;div class="media-left media-middle"&gt; &lt;a href="#"&gt; &lt;img class="media-object" src="..." alt="..."&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class="media-body"&gt; &lt;h4 class="media-heading"&gt;Middle aligned media&lt;/h4&gt; Cras sit amet nibh libero, in gravida nulla. Nulla vel metus scelerisque ante sollicitudin commodo. Cras purus odio, vestibulum in vulputate at, tempus viverra turpis. Fusce condimentum nunc ac nisi vulputate fringilla. Donec lacinia congue felis in faucibus. &lt;div class="media"&gt; &lt;div class="media-left media-middle"&gt; &lt;a href="#"&gt; &lt;img class="media-object" src="..." alt="..."&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class="media-body"&gt; &lt;h4 class="media-heading"&gt;Middle aligned media&lt;/h4&gt; Cras sit amet nibh libero, in gravida nulla. Nulla vel metus scelerisque ante sollicitudin commodo. Cras purus odio, vestibulum in vulputate at, tempus viverra turpis. Fusce condimentum nunc ac nisi vulputate fringilla. Donec lacinia congue felis in faucibus. &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 对齐123media-topmedia-middlemedia-bottom 列表组123456789101112&lt;ul class="list-group"&gt; &lt;li class="list-group-item list-group-item-success"&gt;Dapibus ac facilisis in&lt;/li&gt; &lt;li class="list-group-item list-group-item-info"&gt;Cras sit amet nibh libero&lt;/li&gt; &lt;li class="list-group-item list-group-item-warning"&gt;Porta ac consectetur ac&lt;/li&gt; &lt;li class="list-group-item list-group-item-danger"&gt;Vestibulum at eros&lt;/li&gt;&lt;/ul&gt;&lt;div class="list-group"&gt; &lt;a href="#" class="list-group-item list-group-item-success"&gt;Dapibus ac facilisis in&lt;/a&gt; &lt;a href="#" class="list-group-item list-group-item-info"&gt;Cras sit amet nibh libero&lt;/a&gt; &lt;a href="#" class="list-group-item list-group-item-warning"&gt;Porta ac consectetur ac&lt;/a&gt; &lt;a href="#" class="list-group-item list-group-item-danger"&gt;Vestibulum at eros&lt;/a&gt;&lt;/div&gt; 面板123456789101112131415&lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt;Panel title&lt;/h3&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; Panel content &lt;/div&gt; &lt;div class="panel-footer"&gt;Panel footer&lt;/div&gt;&lt;/div&gt;&lt;!--情景效果--&gt;&lt;div class="panel panel-primary"&gt;...&lt;/div&gt;&lt;div class="panel panel-success"&gt;...&lt;/div&gt;&lt;div class="panel panel-info"&gt;...&lt;/div&gt;&lt;div class="panel panel-warning"&gt;...&lt;/div&gt;&lt;div class="panel panel-danger"&gt;...&lt;/div&gt; Well效果把 Well 用在元素上，就能有嵌入（inset）的简单效果。1&lt;div class="well"&gt;...&lt;/div&gt;]]></content>
      <categories>
        <category>boostrap</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-pages]]></title>
    <url>%2F2017%2F09%2F14%2Fgitbook%2F</url>
    <content type="text"><![CDATA[本文用来说明了如何从零开始基于gitpages搭建一个简易版的电子书。 创建本地gitbook第一步，先安装脚手架工具 npm install gitbook-cli -g 然后，创建一个笔记文件夹 mkdir daisy-note 然后执行 cd daisy-note gitbook init 这样，可以生成这样一个gitbook项目，其中包含下面两个文件 README.md 的内容会显示在书皮上 SUMMARY.md 是目录 ### 启动服务器，查看和编辑书籍 gitbook serve 这样，可以启动一个服务器，然后到 localhost:4000 端口，就可以看到这本书了。 可以修改 SUMMARY.md 来添加书籍目录 12345# Summary* [Introduction](README.md)* [第一章：git](git/index.md) - [第一节：如何创建这样一篇电子书](git/gitbook.md) 创建 git 文件夹，然后里面就可以写笔记了。 ### 托管我的 gitbook 首先到 github.com 上创建 daisy-note 仓库。 为了部署方便，我们把我们的 daisy-note 的内容结构稍微调整一下，把原有的所有内容都放到 content 文件夹中，也就是有这样的目录结构 ➜ daisy-note ls content README.md SUMMARY.md git ➜ daisy-note 然后，把当前项目变成一个 nodejs 的项目： cd daisy-note npm init 然后，package.json 中添加这些代码： 1234567"scripts": &#123; "start": "gitbook serve ./content ./gh-pages", "build": "gitbook build ./content ./gh-pages", "deploy": "node ./scripts/deploy-gh-pages.js", "publish": "npm run build &amp;&amp; npm run deploy", "port": "lsof -i :35729"&#125;, 有了上面的 npm 脚本之后，我们如果我想在本地 4000 端口查看本书，我需要运行 npm start 在准备上传之前，先来创建一个 .gitignore 文件，里面填写 gh-pages node_modules 然后，运行 git init git add -A git commit -a -m"hello my book" git remote add origin git@github.com/DaisyGXL/daisy-note.git git push -u origin master 上面这些完成后，gitbook 的原始代码就被安全的备份到 master 分支了。访问 https://github.com/DaisyGXL/daisy-note 可以看到这些内容。 ### 部署书籍到 gh-pages 这一步，可以手动做： 第一步：运行 npm run build ，来把 md 文件翻译成 html 放到 gh-pages 文件夹 第二步：拷贝 gh-pages 中的所有文件，到本仓库的 gh-pages 分支，然后上传 第三步：以后每次修改完都需要拷贝到 gh-pages 分支 手动做很麻烦，所以，我们采用一个 npm 包，来帮助我们完成上面的操作 cd daisy-note/ npm i --save gh-pages 然后创建 my-note/scripts/deploy-gh-pages.js 里面的内容是： 123456'use strict';var ghpages = require('gh-pages');main();function main() &#123; ghpages.publish('./gh-pages', console.error.bind(console));&#125; 这样，每次书稿有了修改，运行 npm run publish 就可以把书稿部署到 https://daisygxl.github.io/daisy-note 如果本地书稿正在运行中，也可以执行下面命令将书稿进行部署 npm run deploy ** ps: 本文依据happypeter老师的教程整理 最近访客]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>电子书</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mocha+supertest单元测试]]></title>
    <url>%2F2017%2F09%2F14%2Fmocha%2F</url>
    <content type="text"><![CDATA[最近一段时间刚刚接手了一个angular1.3前端+node服务器端多项目，作为一个刚刚入门node的新手，在熟悉了node的代码后便对已有的接口进行了单元测试用例的编写，此篇博客用于简单的记录。 Mocha介绍Mocha是非常流行JavaScript测试框架之一，在浏览器和Node环境都可以使用。 安装1npm i mocha -g 简单测试脚本1.首先写一个简单的例子，add.js1234function add(a, b)&#123; return a+b; &#125; module.exports = add; 2.新建测试脚本 add.test.js，一般命名规则测试脚本和原脚本同名，但是后缀名为.test.js12345678let calcu = require('./add');let should = require("should");describe("add func test",() =&gt; &#123; it('2 add 2 should equal 4',() =&gt; &#123; calcu.add(2,2).should.equal(4) &#125;)&#125;) 3.执行测试用例1mocha demo1/mocha demo1/calcu.test.js describe 表示测试套件，是一序列相关程序的测试it表示单元测试(unit test)，也就是测试的最小单位。 断言库断言库可以理解为比较函数，也就是断言函数是否和预期一致，如果一致则表示测试通过，如果不一致表示测试失败，一个unit test里面可以包含多个断言语句。本身mocha是不包含断言库的，所以必须引入第三方断言库，目前比较受欢迎的断言库 有 should.js、expect.js 、chai，而chai包含should、expect和assert三种风格，可扩展性比较强。这里举例说明should断言方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 全等，相当于=== .exactly (5).should.be.exactly(5) // 对象存在 .ok true.should.be.ok; &apos;yay&apos;.should.be.ok; (1).should.be.ok; (&#123;&#125;).should.be.ok; false.should.not.be.ok; // 真 .true (5===5).should.be.true (err === null).should.be.true; // 相等,相当于 == .eql (&#123; foo: &apos;bar&apos; &#125;).should.eql(&#123; foo: &apos;bar&apos; &#125;); [1,2,3].should.eql([1,2,3]); // see next example it is correct, even if it is different types, but actual content the same [1, 2, 3].should.eql(&#123; &apos;0&apos;: 1, &apos;1&apos;: 2, &apos;2&apos;: 3 &#125;); // 非数字 .NaN (undefined + 0).should.be.NaN; // 判断类型 .typeof user.should.be.type(&apos;object&apos;); &apos;test&apos;.should.be.type(&apos;string&apos;); // 构造函数的一个实例 .instanceof user.should.be.an.instanceof(User); [].should.be.an.instanceOf(Array); // 存在 .exist() should.not.exist(err) //深度包含 .containDeep() [[1],[2],[3]].should.containDeep([[3]]); [[1],[2],[3, 4]].should.containDeep([[3]]); [&#123;a: &apos;a&apos;&#125;, &#123;b: &apos;b&apos;, c: &apos;c&apos;&#125;].should.containDeep([&#123;a: &apos;a&apos;&#125;]); [&#123;a: &apos;a&apos;&#125;, &#123;b: &apos;b&apos;, c: &apos;c&apos;&#125;].should.containDeep([&#123;b: &apos;b&apos;&#125;]); // 抛出异常 .throw()和throwError() (function()&#123; throw new Error(&apos;fail&apos;); &#125;).should.throw(); (function()&#123; throw new Error(&apos;fail&apos;); &#125;).should.throw(&apos;fail&apos;); // http响应的头部包含 .header res.should.have.header(&apos;content-length&apos;); res.should.have.header(&apos;Content-Length&apos;, &apos;123&apos;); // 包含或等价于 .containEql (&#123; b: 10 &#125;).should.containEql(&#123; b: 10 &#125;); ([1, 2, &#123; a: 10 &#125;]).should.containEql(&#123; a: 10 &#125;); 用法常规函数测试如上面的add.test.js 异步函数测试新建文件book.js123456789let fs = require('fs');exports.read = (cb) =&gt; &#123; fs.readFile('./book.txt', 'utf-8', (err, result) =&gt; &#123; if (err) return cb(err); console.log("result",result); cb(null, result); &#125;) &#125; 新建文件book.test.js1234567891011121314let book = require('./book');let expect = require("chai").expect;let book = require('./book');let expect = require("chai").expect;describe("async", () =&gt; &#123; it('read book async', function (done) &#123; book.read((err, result) =&gt; &#123; expect(err).equal(null); expect(result).to.be.a('string'); done(); &#125;) &#125;)&#125;) 运行mocha book.test.js,我们会发现成功了，但是如果我们把book.js增加一个定时函数，改为如下例子：12345678910let fs = require('fs');exports.read = (cb) =&gt; &#123; setTimeout(function() &#123; fs.readFile('./book.txt', 'utf-8', (err, result) =&gt; &#123; if (err) return cb(err); console.log("result",result); cb(null, result); &#125;) &#125;, 3000);&#125; 会发现报如下错误：1Timeout of 2000ms exceeded. 这是因为mocha默认每个测试用例最多执行2000毫秒，如果到时没有得到结果，就报错。所以我们在进行异步操作的时候，需要额外指定timeout时间。1mocha --timeout 5000 book.test.js 这样就保证测试用例成功。 API测试单单使用Mocha和should就几乎可以满足所有JavaScript函数的单元测试。但是对于Node应用而言，不仅仅是函数的集合，比如一个web应用的测试。这时候就需要配合一个http代理，完成Http请求和路由的测试。Supertest是一个HTTP代理服务引擎，可以模拟一切HTTP请求行为。Supertest可以搭配任意的应用框架，从而进行应用的单元测试。1.安装supertestnpm i supertest –save-dev2.传入应用来实例化supertest123let app = new koa();let server = app.listen(0);this.request = supertest(server); 3.调用API进行测试12345678910111213141516171819202122232425//getdescribe('GET /users', function()&#123; it('respond with json', function(done)&#123; request(app) .get('/user') .set('Accept', 'application/json') .expect(200) .end(function(err, res)&#123; should.not.exist(err); res.text.should.containEql('success'); done(); &#125;); &#125;); &#125;);//postdescribe('test login', function()&#123; it('login sucessfully', function (done) &#123; request.post('/user') .send(&#123; username: 'username', password: '123456' &#125;) .end(function (err, res) &#123; should.not.exists(err); done(); &#125;); &#125;); &#125;) 另外，可以通过.attach()方法测试文件上传。 常用命令行12node ./node_modules/.bin/istanbul cover ./node_modules/mocha/bin/_mochaopen coverage/lcov-report/index.html 生命钩子mocha一共四个生命钩子before()：在该区块的所有测试用例之前执行after()：在该区块的所有测试用例之后执行beforeEach()：在每个单元测试前执行afterEach()：在每个单元测试后执行]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>单元测试</tag>
        <tag>mocha</tag>
        <tag>supertest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo和GitPages搭建个人博客]]></title>
    <url>%2F2017%2F08%2F28%2Fblog%2F</url>
    <content type="text"><![CDATA[本文主要介绍了如何基于Hexo生成一个静态博客站点，并通过github发布。 Hexo简介 A fast, simple &amp; powerful blog framework.–Hexo官网 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。它有下面几个特点： 超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一键部署只需一条指令即可部署到Github Pages，或其他网站 丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。 安装安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git 网上有很多的安装教程，这里不做赘述。接下来只需要使用 npm 即可完成 Hexo 的安装。1$ npm install -g hexo-cli 安装 Hexo 完成后，我们首先需要为我们的项目创建一个指定文件夹，在指定文件夹中执行下列命令， Hexo 将会在指定文件夹中新建所需要的文件。1$ hexo init 等待安装，安装完成后，指定文件夹 的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── 继续执行命令12$ hexo g$ hexo s --debug Hexo 将 source 文件夹中除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件夹会被拷贝过去。这个时候，我们在浏览器中访问 http://localhost:4000/ ，就可以看到基于 Hexo 的默认主题的原型。 主题扩展功能首先，我们需要明白： 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 我们约定，将前者称为 站点配置文件，后者称为 主题配置文件 可以通过hexo的官网选择喜欢的模板进行使用。 发布到github.io在github中创建仓库，命名方式为用户名.github.io，一定要以这种方式命名，并且每个github账户只能有一个pages。在站点配置文件中增加发布仓库:1234deploy: type: git repo: https://github.com/DaisyGXL/DaisyGXL.github.io.git branch: master 运行12$ hexo g$ hexo d 完成编译发布过程。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6项目构建]]></title>
    <url>%2F2017%2F08%2F28%2FES6%2F</url>
    <content type="text"><![CDATA[本文主要结合自己学习ES6的过程，说明了如何从零开始搭建一个ES6前端框架，并在大家都很关注的彩票业务中进行应用。 前言：为什么要使用ES6？ECMAScript6，又叫ECMAScript 2015，和ES3以及ES5的区别大概就像下面这个图一样，ES6相对早先几个版本有更加强大的生产力，能够提高开发效率。 ES6一些比较好的特性1.默认参数12345678//ES5function hello(txt) &#123; txt = txt || 'hello world';&#125;//ES6function hello(txt = 'hello') &#123; //减少了代码冗余&#125; 2.字符串模版123456//ES5-引用underscore这个第三方库实现var compiled = _.template("hello: &lt;%= name %&gt;");compiled(&#123;name: 'xueningjiejie'&#125;);//ES6var name = 'xnjj';var txt = `hello $&#123;name&#125;`; 当然，这篇文章不是一篇讲解ES6特性的文章，因此不会一一陈述，那么ES6还有哪些特性呢？1.解构赋值： 改变了参数赋值和变量赋值的形式，使赋值方式更加多样。2.箭头函数3.Set和Map4.异步操作，如Promise()5.类和对象6.模块化…想要了解更多具体特性，请认真研读阮一峰的ECMAScript 6入门 项目构建ES6是无法直接在浏览器中运行的，因此想要实现一个ES6工程并在浏览器中看到实现效果，需要先进行项目构建。 1 基础架构 模块说明： 业务逻辑 写页面，表现为html,js,css，通过js实现和服务器端进行交互 自动构建-编译 把ES6的代码根据需要编译成ES5或ES3（需要兼容IE8以下低级浏览器的时候）的代码。 自动构建-辅助 实现修改代码自动刷新网页（livereload） 文件合并资源压缩（js,css,图片→base64编码） 服务接口 后端服务器提供数据和接口 mock接口 用于开发阶段纯前端的交互测试 2 任务自动化（gulp）定义：减少人工操作，让电脑自动监听操作，记性响应，提高效率。作用：自动化处理sass／less转化为css的编译过程，文件合并，模块依赖，文件压缩。gulp：自动化工具，替代之前流行grant，通过stream流操作使得级联操作非常块，完成任务自动化，顺畅工作流，由nodejs开发。 gulp 使用说明 (全局安装）$ npm instal --global gulp (项目安装）$ npm install --save-dev gulp (根目录创建gulpfile.js/gulpfile.babel.js）$ touch gulpfile.js gulpfile.js文件内容1234var gulp = require('gulp');gulp.task('default', function() &#123;&#125;); (运行）$ gulp (运行并监听）$ gulp --watch 具体使用说明可以阅读gulp中文文档 3 编译工具（ babel, webpack ） babel：js编译器，把ES6代码编译成ES5代码。webpack：处理模块化，项目依赖的关系，import实现。webpack-stream—webpack：对gulp对支持。 4 代码实现 1.创建ES6前端工程,并创建三个并行模块： app server tasks 2.app目录为前端项目代码，包含html（模板页面）,js（交互实现）,css（样式）ps.1:这里的模版页面创建的不是html页面，而是ejs文件，是因为实战工程的服务器端代码是通过express这个nodejs框架创建的。ps.2:js目录下的index.js文件为入口脚本文件，同样的views目录下的index.ejs为入口模板文件。 3.server为服务器端目录，这里面我们使用nodejs来写服务器端代码。在server目录下执行下面命令,在当前目录使用ejs模板引擎,如果执行express出错，先检查下是否已经安装nodejs，并install了express脚手架。 express -e . npm install 4.task为构建工具目录 util–放置常见脚本的目录 args.js–定义gulp命令行脚本 .option就是定义gulp -*中对内容 .argv表示输入对命令行以字符串形式进行解析 scripts.js–构建脚本，通过gulp对js文件进行重命名，压缩和存放 脚本服务文件 pages.js–模板脚本 server.js–服务器脚本 css.js–监听样式脚本 browser.js–浏览器自动监听变化并编译到指定文件夹 clean.js–编译前情况文件夹 build.js–把所有脚本关联起来，编排执行顺序 default.js–默认执行的任务 5.使用npm自动生成package.json文件，有这个文件就可以使用npm来获取依赖包了 npm init 6.创建设置babel编译工具的文件.babelrc 7.创建gulp的配置文件gulpfile.babel.js ps.2:官网上给的是创建gulpfile.js,是ES5使用的，但是当前工程是ES6工程，使用官网给出的文件名运行gulp命令会报错。 12345678910111213141516171819202122232425**最终目录结构**app js--交互实现 class--类 test.js index.js css--样式 views--模板页面 error.ejs index.ejsservertasks util args.js scripts.js pages.js server.js css.js browser.js clean.js build.js default.jspackage.json.babelrcgulpfile.babel.js 这里没有粘贴每个配置文件的内容，若需要可以克隆https://github.com/DaisyGXL/Lemmon-tree.git 仓库的地址获取搭建好的工程es6-project查看具体配置文件，其中我对每个文件的配置和依赖包的用处进行了注释说明。 8.通过npm install * –save-dev命令把涉及到的依赖包依赖到本地，并添加到package.json文件中，可以通过gulp命令检查是否有使用的依赖包没有更新到本地,直到命令行输出下面内容为止，ES6工程基本搭建完成。 ➜ es6 git:(master) gulp[16:53:30] Requiring external module babel-register[16:53:31] Using gulpfile ~/works/es6/gulpfile.babel.js[16:53:31] Starting ‘build’…[16:53:31] Starting ‘clean’…[16:53:31] Finished ‘clean’ after 10 ms[16:53:31] Starting ‘css’…[16:53:31] Finished ‘css’ after 16 ms[16:53:31] Starting ‘pages’…[16:53:31] Finished ‘pages’ after 17 ms[16:53:31] Starting ‘scripts’…[16:53:31] Version: webpack 3.5.5 Asset Size Chunks Chunk Namesindex.js 2.94 kB 0 [emitted] index[16:53:31] Finished ‘scripts’ after 290 ms[16:53:31] Starting ‘browser’…[16:53:31] Finished ‘browser’ after 92 μs[16:53:31] Starting ‘serve’…[16:53:31] Finished ‘serve’ after 77 μs[16:53:31] Finished ‘build’ after 338 ms[16:53:31] Starting ‘default’…[16:53:31] Finished ‘default’ after 25 μs从输出可以看出，gulp执行的顺序，build –&gt; clean –&gt; css –&gt; pages –&gt; scripts，那么为什么会按照这样的顺序执行呢？我们前面创建了一个gulpfile.babel.js，在文件中指定了gulp运行时，先进入task目录。1requireDir('./tasks'); 那么，gulp 会进入task目录寻找一个叫做default.js的文件,该文件中指定了启动时默认要执行的脚本build，也就是编译脚本。在build.js这个文件中，我们来编排编译步骤，即是上面运行的这种步骤。9.无报错后，通过gulp –watch使服务处于监听状态,运行出现最后一行，则启动并监听成功。 ➜ es6 git:(master) gulp –watch[17:02:49] Requiring external module babel-register[17:02:50] Using gulpfile ~/works/es6/gulpfile.babel.js[17:02:50] Starting ‘build’…[17:02:50] Starting ‘clean’…[17:02:50] Finished ‘clean’ after 9.31 ms[17:02:50] Starting ‘css’…[17:02:50] Finished ‘css’ after 16 ms[17:02:50] Starting ‘pages’…[17:02:50] Finished ‘pages’ after 16 ms[17:02:50] Starting ‘scripts’…[17:02:50] Version: webpack 3.5.5 Asset Size Chunks Chunk Namesindex.js 2.94 kB 0 [emitted] index[17:02:50] Finished ‘scripts’ after 281 ms[17:02:50] Starting ‘browser’…[17:02:50] Starting ‘serve’…livereload[tiny-lr] listening on 35729 … 至此，前端开发框架已经搭建好了，编辑index.ejs模板页面显示内容，通过localhost：3000访问 然而，我们发现，有一些ES6的项目网页依赖了livereload包却并不能自动进行刷新，仍然需要手动去刷新，也就是自动构建中的辅助功能未得到实现。那么检查一下在server目录中的app.js中是否缺少这样一行代码：1app.use(require('connect-livereload')()); 最后，因为学习那段时间身边的小伙伴们都很沉迷彩票，就简单做了个彩票业务的demo，有些逻辑还没有写完，后面会不断完善。git仓库地址：https://github.com/DaisyGXL/Lemmon-tree.git 工程名：cp-project 最近访客]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
</search>
